<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6 之 可迭代接口 Iterable</title>
    <url>/2021/12/02/Iterable/</url>
    <content><![CDATA[<blockquote>
<p>为给各种各样的数据结构提供统一的遍历方式，ES6提供了Iterable接口。</p>
</blockquote>
<a id="more"></a>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>在学习ES6的新特性学到<code>for...of</code>的时候，有个问题让我非常困惑，有的资料说<code>for...of</code>循环这种循环方式以后会作为遍历所有数据结构的统一方式,为什么使用<code>for...of</code>遍历普通对象会报错？</p>
</blockquote>
<p>原来是ECMAScript能够表示有结构的数据的数据类型越来越多，从最早的数组，对象，现在又增加了Set、Map,而这些又可以结合使用。为了给各种各样的数据结构提供统一遍历方式，ES2015就提供了Iterable接口（可迭代的），例如任意数据类型都有toString方法，那是因为都实现了统一的规格标准（这种统一的规格标准在编程的专业叫法叫接口）,因为普通对象内部没有实现Iterable接口，所以它不能被for…of遍历。</p>
<blockquote>
<p>那又为什么说for…of循环可以作为遍历所有数据结构的统一方式？</p>
</blockquote>
<p>因为它内部就是去调用被遍历对象的Iterable方法，去得到一个迭代器，从而去遍历内部所有的数据。这也是Iterable接口所约定的内容。换句话说，只要我们的对象也实现了Iterable接口，那就可以实现使用<code>for...of</code>循环去遍历我们的的对象。</p>
<h4 id="Iterable接口实现的内容"><a href="#Iterable接口实现的内容" class="headerlink" title="Iterable接口实现的内容"></a>Iterable接口实现的内容</h4><p>首先，Iterable接口约定的就是我们对象当中必须要挂载一个叫 Iterable的方法。这里举一些画在Iterable接口的几种数据，比如说：Array、Set、Map等等。</p>
<p>Array:</p>
<img src="/2021/12/02/Iterable/iteratorArr.jpg" class title="This is an image">

<p>Set:</p>
<img src="/2021/12/02/Iterable/iteratorSet.png" class title="This is an image">

<p>Map:</p>
<img src="/2021/12/02/Iterable/iteratorMap.png" class title="This is an image">

<p>这些数据内部都实现了Iterable接口，所以他们都能被for…of遍历。</p>
<p>那这个Iterable 方法是干什么的呢?</p>
<p>在arr<a href>Symbol.iterator</a>调用后会返回一个数组迭代器对象（Array Iterator {}），这个迭代器中维护了一个数据指针，我们每调用一次next，这个指针都会往后移一位，而done属性的作用就是表示我们内部的属性是否全部被遍历完了。</p>
<img src="/2021/12/02/Iterable/iteratorPic.png" class title="This is an image">


<blockquote>
<p>总结一下：所有能直接被 for…of循环遍历的数据类型，它都必须要实现Iterable的接口，就是它在内部都必须要挂载Iterable方法，这个方法要返回一个带有next方法的对象，我们不断调用这个next方法就实现了对数据的遍历。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const set &#x3D; new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]);</span><br><span class="line"></span><br><span class="line">const iterable &#x3D; set[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">console.log(iterable.next()); &#x2F;&#x2F; &#123; value: &#39;foo&#39;, done: false &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: &#39;bar&#39;, done: false &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: &#39;baz&#39;, done: false &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现可迭代接口Iterable"><a href="#实现可迭代接口Iterable" class="headerlink" title="实现可迭代接口Iterable"></a>实现可迭代接口Iterable</h4><p>如何在ECMAScript中去实现Iterable接口？</p>
<p>它实际上就是在这个对象中挂载一个Iterable方法，然后在这个方法中去返回一个迭代器对象。挂载一个Iterable方法，主要有三个方面需要满足：</p>
<blockquote>
<ol>
<li>在最外面的对象实现可迭代接口，叫 Iterable，这个接口约定了内部必须要有一个用于返回迭代器的Iterator方法；</li>
<li>在中间的Iterator返回的对象，它实现了迭代器接口，叫Iterator，这个接口约定的是内部必须 要有一个用于迭代的next方法；</li>
<li>在next返回的对象，这个对象实现的是迭代结果接口，叫IterationResult。这个接口约定的就是，我们在这个对象的内部必须要有Value属性用来表示当前被迭代到的数据,它的值可以是任意类型，除此之外还必须有done和布尔值，这个属性用来表示迭代有没有结束。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  [Symbol.iterator]: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      next:function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: &#39;xh&#39;,</span><br><span class="line">          done: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们实现一个能够被<code>for...of</code>遍历的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  store: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;],</span><br><span class="line">  [Symbol.iterator]: function() &#123;</span><br><span class="line">    let index &#x3D; 0;</span><br><span class="line">    const self &#x3D; this; &#x2F;&#x2F; next函数中的this并不是obj对象</span><br><span class="line">    return &#123;</span><br><span class="line">      next:function() &#123;</span><br><span class="line">        const result &#x3D;  &#123;</span><br><span class="line">          value: self.store[index],</span><br><span class="line">          done: index &gt;&#x3D; self.store.length</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        return result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const item of obj) &#123;</span><br><span class="line">  console.log(item); &#x2F;&#x2F; foo bar baz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Iterable</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 Promise</title>
    <url>/2020/07/29/promise/</url>
    <content><![CDATA[<blockquote>
<p>Promis是一种更优的异步编程统一方案。<br>它出现的原因是：直接使用传统回调方式去完成复杂的异步流程就无法避免大量的回调函数嵌套，也就是我们所说的回调地狱。为了避免回调地狱的问题，CommonJS社区提出了Promise的规范，目的就是为异步编程提供一种更合理，更强大的统一解决方案。在ES2015中被标准化，成为语言规范。</p>
</blockquote>
<a id="more"></a>
<h4 id="Promise概述"><a href="#Promise概述" class="headerlink" title="Promise概述"></a>Promise概述</h4><p>Promise：所谓Promise就是一个对象，用来表示一个异步任务最终结束之后，它究竟是成功还是失败。就像是内部对外界做出的一个承诺。开始这个承诺处于待定状态（英文叫Pending），最终有可能成功（英文叫Fulfilled），也有可能失败（英文叫Rejected）。结束之后，承诺最终不管是达成还是失败，你都会有相对应的反应。也就是在承诺状态确定之后，都会有相对应的任务会被自动执行。比如Ajax请求，请求成功就调onFulfilled回调，请求失败就调onRejected回调。</p>
<p>特点：一旦明确了结果过后，就不可能在发生改变</p>
<img src="/2020/07/29/promise/promiseStates.png" class title="This is an promiseStates image">

<h4 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h4><p>Promise是ES2015提供的一个全局类型。</p>
<p>这个函数在构造Promise中被同步执行，这里用于“兑现”承诺。一般我们将异步任务操作的结果通过resolve的参数传递出去，这个promise对象的状态会修改为fulfilled（成功）；reject用来传递失败的，这个promise对象的状态会修改为rejected（失败）。</p>
<p>因为Promise的状态一般确定了就不能修改了，所以在这个函数中只能调用这二者中其一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(100);&#x2F;&#x2F;承诺达成</span><br><span class="line">    &#x2F;&#x2F; 失败的参数，一般我们传递失败的对象用来表示这个承诺为什么失败</span><br><span class="line">    reject(new Error(&#39;promise reject&#39;));&#x2F;&#x2F; 承诺失败</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>即便我们的promise中，没有任何的异步操作，then方法中指定的回调函数仍然会进入到回调队列中排队。也就是说，等待这里同步代码全部执行完了，then方法中的才会执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;&#x2F;&#x2F; onFulfilled回调函数</span><br><span class="line">  console.log(&#39;resolved&#39;, value);</span><br><span class="line">&#125;,function() &#123; &#x2F;&#x2F; onRejcted回调函数</span><br><span class="line">  console.log(&#39;rejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;end&#39;);</span><br></pre></td></tr></table></figure>
<p>调用结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">resolved 100</span><br></pre></td></tr></table></figure>
<h4 id="Promise使用案例"><a href="#Promise使用案例" class="headerlink" title="Promise使用案例"></a>Promise使用案例</h4><p>使用Promise封装Ajax</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url); &#x2F;&#x2F;设置请求方式与请求地址</span><br><span class="line">    &#x2F;&#x2F;设置请求返回的类型为json，这样请求完成返回的数据就不是字符串，而是json对象，es2015新特性</span><br><span class="line">    xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">    &#x2F;&#x2F; 请求完成之后（readyState&#x3D;4），触发的事件，html5添加的新事件</span><br><span class="line">    xhr.onload &#x3D; function () &#123;</span><br><span class="line">      if(this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;).then(function(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;,function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise常见误区"><a href="#Promise常见误区" class="headerlink" title="Promise常见误区"></a>Promise常见误区</h4><p>通过前面的演示发现，从表象上来看Promise的本质也就是使用回调函数方式去定义异步任务结束后所需要执行的任务。只不过这里的回调函数是通过then方法传递进去的，只不过promise将我们的回调分成了两种：成功过后的回调（onFulfilled），失败过后的回调（onRejected）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function onFulfilledc(value) &#123;</span><br><span class="line">  console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;,function onReject () &#123;</span><br><span class="line">  console.log(&#39;onRejected&#39;, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>嵌套使用的方式是使用Promise最常见的错误。错误使用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&quot;&#x2F;api&#x2F;urls.json&quot;).then(function (urls) &#123;</span><br><span class="line">  ajax(urls.users).then(function(users)&#123;</span><br><span class="line">    ajax(urls.users).then(function(users)&#123;</span><br><span class="line">      ajax(urls.users).then(function(users)&#123;</span><br><span class="line">        ajax(urls.users).then(function(users)&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正确做法：借助于Promise.then方法链式调用的特点，尽可能保证异步任务的扁平化</p>
</blockquote>
<h4 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h4><p>Promise的链式调用能最大程度的避免回调嵌套。</p>
<ul>
<li>特点：<ul>
<li>Promise对象的then方法会返回一个全新的Promise对象，所以我们可以使用链式调用的方式添加then方法。</li>
<li>后面的then方法就是在为上一个then返回的Promise注册回调。</li>
<li>前面then方法中回调函数的返回值会作为后面then方法回调的参数。</li>
<li>如果回调中返回的是Promise对象，那后面then方法的回调会等待这个promise的结束。也就是说后面的promise方法，也就是为我们返回的promise对象，去注册了对应的回调。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;);</span><br><span class="line">var promise2 &#x3D; promise.then( &#x2F;&#x2F;then方法作用：为promise对象，去添加状态明确后的回调函数</span><br><span class="line">  function onFulfilled (value) &#123;&#x2F;&#x2F; 成功后的回调</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  function onRejected(error)&#123;&#x2F;&#x2F; 失败后的回调，可省略</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">console.log(promise2 &#x3D;&#x3D;&#x3D; promise); &#x2F;&#x2F; false 返回的是一个全新的promise对象</span><br></pre></td></tr></table></figure>
<p>返回一个全新Promise对象的目的是为了实现一个promise链，一个承诺结束之后，返回一个新的承诺，每个承诺都可以负责一个异步任务相互之间没什么影响。意味着，如果我们不断调用链式then方法，这里的每一个then方法实际上是为了上一个then方法返回的promise对象去添加状态明确后的回调</p>
<p>如果我们返回的不是一个promise而是一个普通的值，这个值就会作为这个then方法返回的这个promise中的值，在下一个then方法接收的回调参数实际上拿到就是这个值，若我们没有返回任何值，那默认返回就是undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(1111);</span><br><span class="line">  &#x2F;&#x2F; 在回调中手动返回一个promise对象，那下一个then方法实际上是为这个promise对象去添加状态明确过后的回调。可以避免不必要的回调嵌套</span><br><span class="line">  &#x2F;&#x2F; return ajax(&#39;api&#x2F;urls.json&#39;);&#x2F;&#x2F; 意思是：这里的ajax调用之后</span><br><span class="line">&#125;)  &#x2F;&#x2F; &#x3D;&gt; Promise</span><br><span class="line">.then(function(value) &#123;&#x2F;&#x2F; 会自动执行这个方法中的回调</span><br><span class="line">  console.log(2222);</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)  &#x2F;&#x2F; &#x3D;&gt; Promise</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(3333);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(4444);</span><br><span class="line">  return &#39;foo&#39;;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(5555);</span><br><span class="line">  console.log(value); &#x2F;&#x2F; foo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果有多个连续的任务，我们就可以使用这种链式调用的方式去避免回调的嵌套，从而尽量保证我们的代码的扁平化。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>处理异常的两种方式：</p>
<ol>
<li>通过then方法第二个参数去指定的失败的回调函数;</li>
<li>用catch方法去指定失败回调。</li>
</ol>
<h5 id="通过then方法第二个参数去指定的失败的回调函数"><a href="#通过then方法第二个参数去指定的失败的回调函数" class="headerlink" title="通过then方法第二个参数去指定的失败的回调函数"></a>通过then方法第二个参数去指定的失败的回调函数</h5><p>onRejected回调实际上是为promise中的异常去做一些处理，在promise失败或者出现异常时，它都会被执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;,function onRejected(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; promise 的结果失败，就会调用这个onRejected回调函数在promise执行过程中出现了异常，或者我们手动抛出异常也会执行这个回调函数</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="用catch方法去指定失败回调"><a href="#用catch方法去指定失败回调" class="headerlink" title="用catch方法去指定失败回调"></a>用catch方法去指定失败回调</h5><p>用catch方法去指定失败回调更为常见，因为这种方式更适合链式调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function onRejcted(error) &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 这里的catch实际上时then方法的别名，因为我们调用它，相当于调用了then方法，不过第一个参数传递的是undefined，第二个是onRejected回调函数</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;)</span><br><span class="line">.then(undefined, function onRejcted(error) &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="这两种方式的差异"><a href="#这两种方式的差异" class="headerlink" title="这两种方式的差异"></a>这两种方式的差异</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 两者的差异对比</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">    return ajax(&#39;error-url&#39;);</span><br><span class="line">&#125;, function onRejcted(error) &#123; &#x2F;&#x2F; 没有捕获到 ajax(&#39;error-url&#39;) 发生的异常</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users11.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">    return ajax(&#39;error-url&#39;);</span><br><span class="line">&#125;) &#x2F;&#x2F; &#x3D;&gt; Promsie &#123;&#125;</span><br><span class="line">.catch(function onRejcted(error) &#123; </span><br><span class="line">  &#x2F;&#x2F; 可以正常捕获到 ajax(&#39;error-url&#39;) 发生的异常。原因：我们这个失败回调，它是注册在上一个（也就是then方法返回的）promise对象上</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>那为什么会出现上面那种情况呢？</p>
<ul>
<li>因为每个then方法它返回的都是一个全新的promise对象，也就是说，我们在后面用链式调用的方式，调用的catch实际上是给前面的then方法返回的promise对象去指定失败回调，并不是直接去给第一个promise对象所指定的。只不过因为这是同一个promise链条，那前面promise上的异常会一直往后传递，所以我们在这里才能捕获到第一个promise中的异常。</li>
<li>而通过then方法第二个参数去指定的失败的回调函数，它只是给第一个promise对象指定的，也就是说它只能捕获到这个promise对象的异常。</li>
</ul>
</li>
<li><p>具体表象上的差异</p>
<ul>
<li>如果我们在then方法中返回了第二个promise，而且这个promise在执行中出现了异常，那我们使用then方法的第二个参数注册的回调，它是捕获不到第二个promise的异常的，因为它只是给第一个promise注册的失败回调。</li>
<li>所以对于链式调用的情况下，建议使用第二种（catch）方式，去分开指定成功回调和失败回调。因为promise链条上任何一个异常都会被一直向后传递直至被捕获。也就是说，这种方式更像是为整个promise链条注册的失败回调，相对说更通用。</li>
</ul>
</li>
</ul>
<h4 id="Promise-静态方法"><a href="#Promise-静态方法" class="headerlink" title="Promise 静态方法"></a>Promise 静态方法</h4><h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><p>Promise.resolve()的作用：快速将一个值转化为promise对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)&#x2F;&#x2F;直接返回一个状态为fulfilled的promise对象,这个&#39;foo&#39;就会作为这个promise对象所返回的值</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">    console.log(value);&#x2F;&#x2F; foo</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面等价于下面的</span><br><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(&#39;foo&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.resolve方法如果接收到的是另一个promise对象，这个promise对象则会原样返回，也就是我们用Promise.resolve去包裹一个promise，得到的是被包裹的那个promise。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;);</span><br><span class="line">var promise2 &#x3D; Promise.resolve(promise);</span><br><span class="line">console.log(promise &#x3D;&#x3D;&#x3D; promise2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>若我们传入的是一个对象，这个对象也有与promise一样的then方法，这样的对象也可以作为一个promise对象被执行，在后面的then方法中也能拿到这里所对应传入的值。</p>
<p>这种带有then方法的对象实现了thenable接口，也就是说它是一个可以被then的对象。支持这种对象的原因，是因为在promise没有普及之前，我们都是使用第三方库去实现promise，如果我们想将第三方的promise对象换成原生的promise，就可以借助这样的机制，因为在第三方promise对象中也有相同的这种then方法，那就可以通过Promise.resolve将其转换成原生的promise对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#123;</span><br><span class="line">  then:function(onFulfilled, onRejected)&#123;</span><br><span class="line">      onFulfilled(&#39;foo&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><p>Promise.resolve()的作用：快速创建一个失败的promise对象。它的参数，无论我们传入什么参数，都会作为promise失败的理由（失败的原因）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject(new Error(&#39;rejected&#39;))</span><br><span class="line">.catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.reject(&#39;anything&#39;)</span><br><span class="line">.catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Promise-并行执行"><a href="#Promise-并行执行" class="headerlink" title="Promise 并行执行"></a>Promise 并行执行</h4><p>前面的操作都是通过promise去串联多个异步任务，也就是一个任务之后，再去开启下一个任务。相对于传统的回调方式Promise提供了更扁平的异步体验。如果需要同时并行执行多个异步任务（比如请求多个接口，且他们之间没有相互依赖），promise也可以提供更完善的体验。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()的作用：可以将多个Promise合并为一个Promise统一去管理。</p>
<p>Promise.all():参数是数组，里面是一个个promise对象（每个promise对象可看作是一个异步任务），返回一个全新的promise对象。当内部所有的promise完成之后，我们所返回的这个全新的promise才会完成，此时这个promise对象拿到的结果就是数组，这个数组包含每个异步任务执行后的结果。</p>
<blockquote>
<p>注意：在这个任务过程中，只有这里面的任务都成功结束了，这个新的promise才会成功结束，如果这里有其中一个任务结束了，那这个promise就会以失败结束。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise.all()能够很好的处理这种并行的异步请求</span><br><span class="line">var promise &#x3D; Promise.all([</span><br><span class="line">    ajax(&#39;&#x2F;api&#x2F;users.json&#39;),</span><br><span class="line">    ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)</span><br><span class="line">]);</span><br><span class="line">promise.then(function (values)&#123;</span><br><span class="line">    console.log(values); &#x2F;&#x2F; (2) [Array(2), Array(2)]</span><br><span class="line">&#125;).catch(function (error)&#123;</span><br><span class="line">    console.log(error); &#x2F;&#x2F; GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;posts11.json 404 (Not Found)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>综合使用串联和并联这两种方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">    const urls &#x3D; Object.values(value);</span><br><span class="line">    const task &#x3D; urls.map(url &#x3D;&gt; ajax(url));&#x2F;&#x2F; 返回的task是promise对象数组</span><br><span class="line">    return Promise.all(task);</span><br><span class="line">&#125;)</span><br><span class="line">.then(values &#x3D;&gt; &#123;</span><br><span class="line">    console.log(values);&#x2F;&#x2F; (2) [Array(2), Array(2)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promis.race()的作用：也可以将多个Promise对象组合成一个全新的Promise对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)</span><br><span class="line">const timeout &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        reject(new Error(&#39;timeout&#39;))</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 效果：如果500毫秒内请求完成了，就可以正常得到响应结果，如果500毫秒之后，请求就无法将请求返回因为在500毫秒后我们的第二个promise会以失败方式结束，而race方法就是以第一个结束的promise为准</span><br><span class="line">Promise.race([</span><br><span class="line">  request,</span><br><span class="line">  timeout</span><br><span class="line">])</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value) &#x2F;&#x2F; Array(2)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error) &#x2F;&#x2F; Error: timeout</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Promise-all-）与-Promise-race-的区别"><a href="#Promise-all-）与-Promise-race-的区别" class="headerlink" title="Promise.all(）与 Promise.race()的区别"></a>Promise.all(）与 Promise.race()的区别</h5><p>Promose.all()等待所有的任务结束后才会结束（所有的任务成功结束，才会成功结束），Promise.race()只会等待第一个结束的任务，也就是说只要任何一个任务完成了，那我们这个返回的新的Promise也就会完成。</p>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 Proxy使用</title>
    <url>/2021/12/02/proxy/</url>
    <content><![CDATA[<blockquote>
<p>在ES6中，Proxy是为对象设置访问代理器（代理如同门卫），它可以轻松监视到对象的读写过程。</p>
</blockquote>
<a id="more"></a>

<h4 id="Proxy的应用场景示例"><a href="#Proxy的应用场景示例" class="headerlink" title="Proxy的应用场景示例"></a>Proxy的应用场景示例</h4><p>在ES6之前，如果我们想要监视某个对象的属性读写，那我们可以使用ES5提供的Object.defineProperty方法来为我们的对象添加属性，捕获到对象属性的读写过程（Vue3.0之前就是使用这个方法实现数据响应，从而实现数据双向绑定）。</p>
<h4 id="那我们如何使用Proxy？"><a href="#那我们如何使用Proxy？" class="headerlink" title="那我们如何使用Proxy？"></a>那我们如何使用Proxy？</h4><ul>
<li>new Proxy(<code>需要代理的目标对象</code>， <code>代理的处理对象</code>);</li>
<li>首先抛出示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 第一个参数是需要代理的目标对象（person），第二个参数也是一个对象（代理的处理对象）</span><br><span class="line">const personProxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 两个参数：目标对象和属性名</span><br><span class="line">  get(target, property)&#123;</span><br><span class="line">    return property in target ? target[property]: &#39;default&#39;;</span><br><span class="line">    console.log(target, property); &#x2F;&#x2F; &#123; name: &#39;xh&#39;, age: 20 &#125; name</span><br><span class="line">    &#x2F;&#x2F; return 100;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 三个参数：目标对象，属性名，属性值</span><br><span class="line">  set(target, property, value)&#123;</span><br><span class="line">    if(property &#x3D;&#x3D;&#x3D; &#39;age&#39;) &#123; &#x2F;&#x2F; 在这里可以对属性值做一些处理</span><br><span class="line">      if (!Number.isInteger(value))&#123;</span><br><span class="line">        throw new TypeError(&#96;$&#123;value&#125; is not an int&#96;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target[property] &#x3D; value;</span><br><span class="line">    console.log(target, property, value); &#x2F;&#x2F; &#123; name: &#39;xh&#39;, age: 20 &#125; gender true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(personProxy.name); &#x2F;&#x2F; xh</span><br><span class="line">console.log(personProxy.xxx); &#x2F;&#x2F; default</span><br><span class="line">&#x2F;&#x2F; personProxy.age &#x3D; &#39;ss&#39;; &#x2F;&#x2F; 报错</span><br><span class="line">personProxy.gender &#x3D; true</span><br></pre></td></tr></table></figure>
<hr>
<p>都知道在Vue3.0中使用Proxy替代了Object.defineProperty(),那相对于Object.defineProperty()，Proxy有什么优势呢?</p>
<h4 id="Proxy的优势"><a href="#Proxy的优势" class="headerlink" title="Proxy的优势"></a>Proxy的优势</h4><h5 id="Proxy能够监视到更多对象操作"><a href="#Proxy能够监视到更多对象操作" class="headerlink" title="Proxy能够监视到更多对象操作"></a>Proxy能够监视到更多对象操作</h5><p>Proxy更强大一些：defineProperty 只能监视对象属性的读写，而Proxy能够监视到更多对象操作（比如说delete 操作，对对象方法的调用等等）。</p>
<ul>
<li>deleteProperty代理方法：当外部对当前这个代理对象进行delete操作的时,会自动执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">const personProxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 两个参数：代理目标对象，所删除的属性名</span><br><span class="line">  deleteProperty(target, property)&#123;</span><br><span class="line">    console.log(&#39;delete&#39;, property); &#x2F;&#x2F; delete age</span><br><span class="line">    delete target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">delete personProxy.age;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123; name: &#39;xh&#39; &#125;</span><br></pre></td></tr></table></figure>
<p>当然不仅仅是监视delete操作，还有其他的，Proxy可以检测到的对象操作如下：</p>
<table>
<thead>
<tr>
<th>handler方法</th>
<th>触发方式</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>读取某个属性</td>
</tr>
<tr>
<td>set</td>
<td>写入某个属性</td>
</tr>
<tr>
<td>has</td>
<td>in 操作符</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete 操作符</td>
</tr>
<tr>
<td>getProperty</td>
<td>Object.getPropertypeOf()</td>
</tr>
<tr>
<td>setProperty</td>
<td>Object.setPropertypeOf()</td>
</tr>
<tr>
<td>isExtensible</td>
<td>Object.isExtensible()</td>
</tr>
<tr>
<td>preventExtensions</td>
<td>Object.preventExtensions()</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor</td>
<td>Object.getOwnPropertyDescriptor()</td>
</tr>
<tr>
<td>defineProperty</td>
<td>Object.defineProperty()</td>
</tr>
<tr>
<td>ownkeys</td>
<td>Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()</td>
</tr>
<tr>
<td>apply</td>
<td>调用一个函数</td>
</tr>
<tr>
<td>construct</td>
<td>用 new 调用一个函数</td>
</tr>
</tbody></table>
<p>并且 Proxy 更好的支持数组对象的监视。<br>Object.defineProperty监听对数组的操作，就是重写数组的操作方法，也是Vue.js中所使用的方式（用自定义的方法覆盖掉数组原型上的方法比如说 push 等等），以此来劫持数组调用的过程。</p>
<p>如何使用 Proxy 对象监视数组呢？再举个栗子，你就明白了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list &#x3D; [];</span><br><span class="line">const listProxy &#x3D; new Proxy(list, &#123;</span><br><span class="line">  set(target,property, value) &#123;</span><br><span class="line">    console.log(&#39;set&#39;,property, value);</span><br><span class="line">    target[property] &#x3D; value;</span><br><span class="line">    return true; &#x2F;&#x2F; 表示设置成功</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">listProxy.push(100); &#x2F;&#x2F;set 0 100 (0 是数组下标，100 是数组下标对应的值)</span><br></pre></td></tr></table></figure>
<p>使用Proxy对数组进行监听不需要进行额外的操作，相对于Object.defineProperty就简便很多。</p>
<h5 id="Proxy-是以非侵入的方式监管了对象的读写"><a href="#Proxy-是以非侵入的方式监管了对象的读写" class="headerlink" title="Proxy 是以非侵入的方式监管了对象的读写"></a>Proxy 是以非侵入的方式监管了对象的读写</h5><p>这是什么意思呢：一个已经定义好的对象，我们不需要对对象本身做任何的操作就可以监听到对象的读写。而Object.defineProperty就要求我们必须要经过特定的方式，单独去定义对象当中那些需要被监视的属性，那样对一个已经存在的属性，我们要做很多额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;&#125;</span><br><span class="line">Object.defineProperty(person, &#39;name&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&#39;name 被访问&#39;);</span><br><span class="line">    return person._name</span><br><span class="line">  &#125;,</span><br><span class="line">  set (value) &#123;</span><br><span class="line">    console.log(&#39;name 被设置&#39;);</span><br><span class="line">    person._name &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person, &#39;age&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&#39;age 被访问&#39;);</span><br><span class="line">    return person._age</span><br><span class="line">  &#125;,</span><br><span class="line">  set (value) &#123;</span><br><span class="line">    console.log(&#39;age 被设置&#39;);</span><br><span class="line">    person._age &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;jack&#39;;</span><br><span class="line">console.log(person.name); </span><br><span class="line">&#x2F;&#x2F;输出log如下：name 被设置 name 被访问 jack jack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相对于Object.defineProperty方式，Proxy 方式更合理，且代码更加简洁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person2 &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const personProxy &#x3D; new Proxy(person2, &#123;</span><br><span class="line">  get(target, property)&#123;</span><br><span class="line">    return target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, property, value) &#123;</span><br><span class="line">    target[property] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">personProxy.name &#x3D; &#39;jack&#39;;</span><br><span class="line">console.log(personProxy.name); &#x2F;&#x2F; jack</span><br></pre></td></tr></table></figure>

<h5 id="Proxy监听性能有所提升"><a href="#Proxy监听性能有所提升" class="headerlink" title="Proxy监听性能有所提升"></a>Proxy监听性能有所提升</h5><p>Proxy监听相对于Object.defineProperty性能更好。因为Proxy在get里进行递归（不get就不递归），什么时候用（也就是说什么时候get到）什么时候才监听，而Object.defineProperty是一次性全部递归完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">const proxyData &#x3D; new Proxy(data, &#123;</span><br><span class="line">    get(target, key, receiver) &#123;</span><br><span class="line">        &#x2F;&#x2F; 只处理本身（非原型的）属性</span><br><span class="line">        const ownKeys &#x3D; Reflect.ownKeys(target)</span><br><span class="line">        if (ownKeys.includes(key)) &#123;</span><br><span class="line">            console.log(&#39;get&#39;, key) &#x2F;&#x2F; 监听</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const result &#x3D; Reflect.get(target, key, receiver)</span><br><span class="line">        return result &#x2F;&#x2F; 返回结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Proxy总结"><a href="#Proxy总结" class="headerlink" title="Proxy总结"></a>Proxy总结</h4><blockquote>
<p>Proxy 能够监视到更多对象操作,比如说可监听 新增/删除 属性等等<br>Proxy 是以非侵入的方式监管了对象的读写<br>Proxy 性能更好</p>
</blockquote>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 Reflect</title>
    <url>/2021/12/02/reflect/</url>
    <content><![CDATA[<blockquote>
<p>Reflect是ES6中提供的一种全新的内置对象（统一的对象操作API）。</p>
</blockquote>
<a id="more"></a>

<h4 id="Reflect的作用"><a href="#Reflect的作用" class="headerlink" title="Reflect的作用"></a>Reflect的作用</h4><p>刚开始接触Reflect的时候，我在想为什么需要这个东西？</p>
<p>查了一些资料才发现，Reflect最大的意义就是：<strong>统一提供一套用于操作对象的API</strong>。因为在这之前呢，我们去操作对象时有可能用Object对象上的一些方法，也可能是用delete 、in这样的操作符。那这样对于新手来说太乱了，并没有什么规律，Reflect对象就很好的解决了这样的问题，它统一了对象的操作。</p>
<p>例如下面的例子，我们可以用<code>Reflect.has()</code>代替<code>in</code>操作符，使用<code>Reflect.deleteProperty</code>代替<code>delete</code>操作符。这样看起来就很统一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age:18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#39;name&#39; in obj); &#x2F;&#x2F; true 使用的是操作符</span><br><span class="line">console.log(delete obj[&#39;age&#39;]);&#x2F;&#x2F; true 使用的是操作符</span><br><span class="line">console.log(Object.keys(obj)); &#x2F;&#x2F; [&#39;name&#39;]  使用的是对象方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用新的Reflect方式，进行同样的操作</span><br><span class="line"></span><br><span class="line">console.log(Reflect.has(obj, &#39;name&#39;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Reflect.deleteProperty(obj, &#39;age&#39;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Reflect.ownKeys(obj)); &#x2F;&#x2F; [&#39;name&#39;]</span><br></pre></td></tr></table></figure>
<p>注意：以前的那种操作方式还是可以使用的，ECMAScript官方希望经过一段时间，以后的标准当中就会将之前的那些方式废弃掉，推荐使用Reflect。</p>
<h4 id="Proxy与Reflect配合使用"><a href="#Proxy与Reflect配合使用" class="headerlink" title="Proxy与Reflect配合使用"></a>Proxy与Reflect配合使用</h4><p>Reflect属于一个静态类，它不能通过new Reflect的方式去构建一个实例对象，只能够去调用这个静态类中的静态方法（如 Math 对象一样）。而且Reflect内部封装了一系列对对象的底层操作。提供了14个静态方法，其中有一个废弃掉了，剩下13个。这个13个对象的方法的方法名与<a href="https://laceyx.github.io/2021/01/22/proxy/#more">Proxy中对象中处理对象的方法成员是完全一致的</a>。Reflect成员方法就是Proxy处理对象的默认实现。</p>
<p>在Proxy处理对象中，如果我们没有添加具体的处理方法（比如get/set），那么它的内部这些get/set到底是怎样执行的呢？看个小例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;123&#39;,</span><br><span class="line">  bar: &#39;456&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(obj, &#123;</span><br><span class="line">  &#x2F;&#x2F; 我们在定义get&#x2F;set 这样的逻辑时，更标准的做法是：先去实现自己所需要的js逻辑，</span><br><span class="line">  &#x2F;&#x2F; 最后返回通过Reflect中对应方法调用的结果。</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    console.log(&#39;watch login~&#39;); &#x2F;&#x2F;模拟我们调用的js逻辑</span><br><span class="line">    return Reflect.get(target, property)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(proxy.foo) </span><br></pre></td></tr></table></figure>
<p>其实Proxy处理对象内部，默认实现的逻辑就是调用了Reflect对象当中所对应的方法。也就是说我们没有定义get方法就等同于是我们定义了一个get方法，然后将参数原封不动传给Reflect的get方法，这个结果是一样的。</p>
<p>我们在定义get/set这样的逻辑时，更标准的做法是：先去实现自己所需要的js逻辑，最后返回通过Reflect中对应方法调用的结果。</p>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 Symbol</title>
    <url>/2021/12/02/symbol/</url>
    <content><![CDATA[<blockquote>
<p>Symbol是一种全新的基本数据类型，在未来可能还会添加一个BigInt的原始数据类型，用于存放更长的数字(这个现在处于stage-4阶段，标准化之后，那就有8种原始数据类型)。</p>
</blockquote>
<a id="more"></a>

<h4 id="为什么需要Symbol？"><a href="#为什么需要Symbol？" class="headerlink" title="为什么需要Symbol？"></a>为什么需要Symbol？</h4><p>在ES6之前对象的属性名都是字符串，而字符串的属性名是有可能重复的，那重复就会产生冲突。</p>
<h4 id="实际场景出现的问题"><a href="#实际场景出现的问题" class="headerlink" title="实际场景出现的问题"></a>实际场景出现的问题</h4><p>很多情况下我们大量使用第三方模块，很多时候我们需要扩展第三方模块中的对象，此时我们不知道这个对象中是否存在某个指定的键，如果这时候贸贸然直接扩展，就有可能会产生冲突。</p>
<h4 id="以前的解决方案"><a href="#以前的解决方案" class="headerlink" title="以前的解决方案"></a>以前的解决方案</h4><p>以前是采用约定的方式，例如，a文件下的键就命名为a_foo,b文件下就命名为b_foo,但是这并没有解决问题，只是规避问题。假如在多人合作开发时有人遵守约定，那就很容易出问题。</p>
<p>举个约定的栗子(便于展示，这里用 ==== 代表一个单独的文件)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; share.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">const cache &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;a.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">cache[&#39;a_foo&#39;] &#x3D; Math.random();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">cache[&#39;b_foo&#39;] &#x3D; &#39;123&#39;;</span><br></pre></td></tr></table></figure>
<p>而ES6为了解决上述问题，提供了一个全新的原始数据类型Symbol</p>
<h4 id="Symbol的作用"><a href="#Symbol的作用" class="headerlink" title="Symbol的作用"></a>Symbol的作用</h4><p>Symbol的作用是表示一个独一无二的值。在实际应用中，它最主要的作用就是为对象添加独一无二的属性名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s &#x3D; Symbol();</span><br><span class="line">console.log(s); &#x2F;&#x2F; Symbol()</span><br><span class="line">console.log(typeof s) &#x2F;&#x2F; symbol</span><br><span class="line"></span><br><span class="line">console.log(Symbol() &#x3D;&#x3D;&#x3D; Symbol());&#x2F;&#x2F; false，值是唯一的，我们没有办法去创建一个完全一样的Symbol成员</span><br></pre></td></tr></table></figure>
<h4 id="Symbol-的使用"><a href="#Symbol-的使用" class="headerlink" title="Symbol 的使用"></a>Symbol 的使用</h4><h5 id="Symbol允许传入字符串参数"><a href="#Symbol允许传入字符串参数" class="headerlink" title="Symbol允许传入字符串参数"></a>Symbol允许传入字符串参数</h5><p>考虑到开发中的调试，Symbol函数允许我们传入字符串作为调试文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Symbol(&#39;foo&#39;));&#x2F;&#x2F; Symbol(foo)</span><br><span class="line">console.log(Symbol(&#39;bar&#39;));&#x2F;&#x2F; Symbol(bar)</span><br><span class="line">console.log(Symbol(&#39;baz&#39;));&#x2F;&#x2F; Symbol(baz)</span><br></pre></td></tr></table></figure>
<h5 id="使用Symbol作为对象属性名"><a href="#使用Symbol作为对象属性名" class="headerlink" title="使用Symbol作为对象属性名"></a>使用Symbol作为对象属性名</h5><p>在ES6及之后，对象允许使用Symbol类型的值作为属性名。现在对象的属性名可以是两种类型：string和Symbol。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;</span><br><span class="line">obj[Symbol()] &#x3D; &#39;123&#39;</span><br><span class="line">obj[Symbol()] &#x3D; &#39;456&#39;;</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; [Symbol()]: &#39;123&#39;, [Symbol()]: &#39;456&#39; &#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    [Symbol()]: 123</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);&#x2F;&#x2F; &#123; [Symbol()]: 123 &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Symbol去创建私有属性"><a href="#使用Symbol去创建私有属性" class="headerlink" title="使用Symbol去创建私有属性"></a>使用Symbol去创建私有属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; 使用Symbol去创建私有的属性名</span><br><span class="line">const name &#x3D; Symbol();</span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">    [name]: &#39;xh&#39;,</span><br><span class="line">    say() &#123;</span><br><span class="line">        console.log(this[name]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; b.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; person[Symbol()];&#x2F;&#x2F; 访问不到a.js文件中的person的name属性</span><br><span class="line">person.say();&#x2F;&#x2F; xh</span><br></pre></td></tr></table></figure>
<h4 id="Symbol补充"><a href="#Symbol补充" class="headerlink" title="Symbol补充"></a>Symbol补充</h4><h5 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h5><p>每次通过Symbol函数创建的值一定是唯一值，不管我们传入的描述文本是不是相同的，那每次调用Symbol函数它得到的值都是全新的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  Symbol() &#x3D;&#x3D;&#x3D; Symbol(), &#x2F;&#x2F; false</span><br><span class="line">  Symbol(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; Symbol(&#39;foo&#39;) &#x2F;&#x2F; false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="如何在全局复用相同的Symbol值？"><a href="#如何在全局复用相同的Symbol值？" class="headerlink" title="如何在全局复用相同的Symbol值？"></a>如何在全局复用相同的Symbol值？</h5><ul>
<li>使用全局变量的方式去实现</li>
<li>使用Symbol类型提供的静态方法（for）去实现<ul>
<li>使用for方法，这个方法可以接受一个字符串作为参数，相同的字符串就一定会返回相同的Symbol类型的值。这个方法内部维护了一个全局的注册表，为我们的字符串和symbol值提供了一一对应的关系。</li>
<li><blockquote>
<p>注意：这个方法内部维护的是字符串和symbol值一一对应的关系，如果我们传入的不是字符串，那这个方法会将其自动转换为字符串。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s1 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">const s2 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">console.log(s1 &#x3D;&#x3D;&#x3D; s2);&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Symbol.for(&#39;true&#39;) &#x3D;&#x3D;&#x3D; Symbol.for(true)</span><br><span class="line">); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h5 id="Symbol内置常量"><a href="#Symbol内置常量" class="headerlink" title="Symbol内置常量"></a>Symbol内置常量</h5><p>Symbol类型中提供了很多内置Symbol常量，用来去作为内部方法的标识，这些标识符可以让自定义对象去实现一些JS中内置的接口。例如：iterator、hasInstance等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这种symbol（symbol常量）为我们后面为对象实现迭代器时会经常用到</span><br><span class="line">console.log(Symbol.iterator);</span><br><span class="line">console.log(Symbol.hasInstance);</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 自定义对象的toString标签：可以添加一个特定的成员去标识（使用字符串去添加标识符，可能会跟内部成员产生冲突，ECMAScript要求我们使用Symbol来实现这个标识）</span><br><span class="line">  [Symbol.toStringTag]: &#39;Xobject&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;原本的： [object Object] &#x3D;&#x3D;&gt;叫对象的toString标签</span><br><span class="line">console.log(obj.toString()) &#x2F;&#x2F;修改后的： [object Xobject]</span><br></pre></td></tr></table></figure>
<h5 id="使用symbol值去作为对象的属性名"><a href="#使用symbol值去作为对象的属性名" class="headerlink" title="使用symbol值去作为对象的属性名"></a>使用symbol值去作为对象的属性名</h5><p>使用symbol值去作为对象的属性名，通过for…of..循环、Object.keys()、JSON.toStringify()序列化，都是获取不到的。这种特性表示Symbol类型特别适合作为对象的私有属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  [Symbol()]: &#39;symbol value&#39;,</span><br><span class="line">  for: &#39;normal value&#39;</span><br><span class="line">&#125;</span><br><span class="line">for (var key in obj) &#123;</span><br><span class="line">  console.log(key); &#x2F;&#x2F; foo</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(obj));&#x2F;&#x2F; [&#39;foo&#39;]</span><br><span class="line">console.log(JSON.stringify(obj)) &#x2F;&#x2F; &#123;&quot;for&quot;:&quot;normal value&quot;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何获取symbol类型的属性名"><a href="#如何获取symbol类型的属性名" class="headerlink" title="如何获取symbol类型的属性名"></a>如何获取symbol类型的属性名</h5><p>使用Object.getOwnPropertySymbols(obj)方法，作用与Object.keys方法类似。不同的是Object.keys方法只能获取到对象中所有的字符串属性名，而Object.getOwnPropertySymbols(obj)方法，它获取到的全是Symbol属性名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.getOwnPropertySymbols(obj)); &#x2F;&#x2F; [ Symbol() ]</span><br></pre></td></tr></table></figure>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程初识</title>
    <url>/2021/12/04/AsyncCode/AsyncCode1/</url>
    <content><![CDATA[<blockquote>
<p>单线程 JavaScript 异步方案。本篇讲述异步编程的某些概念，以及需要异步编程方案的原因</p>
</blockquote>
<a id="more"></a>

<h3 id="异步编程：单线程-JavaScript-异步方案"><a href="#异步编程：单线程-JavaScript-异步方案" class="headerlink" title="异步编程：单线程 JavaScript 异步方案"></a>异步编程：单线程 JavaScript 异步方案</h3><p>目前主流的JavaScript环境都是以单线程模式去执行的JavaScript代码</p>
<h4 id="采用单线程模式工作的原因"><a href="#采用单线程模式工作的原因" class="headerlink" title="采用单线程模式工作的原因"></a>采用单线程模式工作的原因</h4><p>与它最早的设计初衷有关，最早JavaScript这门语言就是运行在浏览器端的脚本语言，它的目的就是实现页面中的动态交互，交互的核心就是进行DOM操作，这也就决定了它必须使用单线程模型，否则就会出现很复杂的线程同步问题。</p>
<p>试想一下，假定我们在JavaScript中同时有多个线程同时工作，其中某一个线程修改了某个DOM元素，而另外一个线程同时又删除了该DOM元素，那此时浏览器就无法明确该以哪个线程的结果为准，为了避免这些线程同步问题。JavaScript一开始就设计了单线程模式工作。</p>
<h4 id="单线程：JS执行环境中负责执行代码的线程只有一个。"><a href="#单线程：JS执行环境中负责执行代码的线程只有一个。" class="headerlink" title="单线程：JS执行环境中负责执行代码的线程只有一个。"></a>单线程：JS执行环境中负责执行代码的线程只有一个。</h4><ul>
<li>优点：更安全，更简单</li>
<li>缺点：如果我们遇到某个特别耗时的任务，那后面的任务都必须去排队等待这个任务的结束。导致整个程序的执行会被拖延，出现假死的情况。</li>
<li>为了解决耗时任务阻塞执行的这种问题，JavaScript将任务的执行模式分成了两种<ul>
<li>同步模式（Synchronous）</li>
<li>异步模式（Asynchronous）</li>
</ul>
</li>
</ul>
<h3 id="同步模式（Synchronous）"><a href="#同步模式（Synchronous）" class="headerlink" title="同步模式（Synchronous）"></a>同步模式（Synchronous）</h3><p>概念：同步模式指的就是我们代码当中的任务依次执行，那我们后一个任务必须等到前一个任务结束才能开始执行。程序的执行顺序跟我们代码的编写顺序是完全一致的。<br>在单线程情况下，我们大多数任务会以同步模式去执行。</p>
<p>示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;global begin&#39;)</span><br><span class="line">function bar () &#123;</span><br><span class="line">  console.log(&#39;bar task&#39;);</span><br><span class="line">&#125;</span><br><span class="line">function foo () &#123;</span><br><span class="line">  console.log(&#39;foo task&#39;);</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(&#39;global end&#39;)</span><br></pre></td></tr></table></figure>
<p>在console 中的执行显示  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global begin</span><br><span class="line">foo task</span><br><span class="line">bar task</span><br><span class="line">global end</span><br></pre></td></tr></table></figure>
<h5 id="在调用栈中的执行过程"><a href="#在调用栈中的执行过程" class="headerlink" title="在调用栈中的执行过程"></a>在调用栈中的执行过程</h5><ul>
<li>默认压入一个匿名的调用（anonymous）：可以理解为把全部的代码放在一个匿名的函数中去执行，然后逐行执行我们的代码</li>
<li>console.log(‘global begin’)执行，log打印后，然后弹出</li>
<li>foo()-&gt;console.log(‘foo task’);执行，log打印后，然后弹出 -&gt; bar() -&gt;console.log(‘bar task’);执行，log打印后，</li>
<li>然后弹出 -&gt; bar函数执行结束，然后弹出 -&gt; foo函数执行结束，然后弹出</li>
<li>console.log(‘global end’)，执行，log打印，弹出<br>整体代码全部结束，我们的调用栈就被清空掉</li>
</ul>
<blockquote>
<p>这里的调用栈只是一个专业的说法，通俗说，JS在执行引擎中维护了一个正在工作的工作表，记录当前正在做的一些事情，当这个工作表中所有的任务被清空后，这一轮的工作就结束了。</p>
</blockquote>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>如果其中的某一个任务或者某一行代码，执行时间过长，那后面的任务就会被延迟，我们把这种延迟叫做阻塞。</p>
<p>这种阻塞于用户而言就是页面就会卡顿，就必须要有异步模式来去解决我们程序当中那些无法避免的耗时操作（例如我们在浏览器中的Ajax操作，或者node端的大文件读写）。</p>
<h3 id="异步模式（Asynchronous）"><a href="#异步模式（Asynchronous）" class="headerlink" title="异步模式（Asynchronous）"></a>异步模式（Asynchronous）</h3><blockquote>
<p>特点：不会去等待这个任务的结束才开始下一个任务。对于耗时任务，它都是开启过后就立即往后执行下一个任务，耗时任务的后续逻辑一般会通过回调函数的方式定义。耗时任务完成后会自动执行我们传入的回调函数。</p>
</blockquote>
<p>异步模式对于JavaScript非常重要，因为如果没有异步模式，单线程的JavaScript 语言就无法同时处理大量耗时任务。  </p>
<p>异步模式的代码执行顺序是比较混乱的，示例代码的执行顺序如下</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;global begin&#39;);</span><br><span class="line">setTimeout(function timer1 ()&#123;</span><br><span class="line">  console.log(&#39;timer1 invoke&#39;);</span><br><span class="line">&#125;,1800)</span><br><span class="line">setTimeout(function timer2()&#123;</span><br><span class="line">  console.log(&#39;timer2 invoke&#39;);</span><br><span class="line">  setTimeout(function timerInner()&#123;</span><br><span class="line">      console.log(&#39;inner invoke&#39;)</span><br><span class="line">  &#125;,1000)    </span><br><span class="line">&#125;,1000)</span><br><span class="line">console.log(&#39;global end&#39;);  </span><br></pre></td></tr></table></figure>
<h5 id="Call-stack"><a href="#Call-stack" class="headerlink" title="Call stack"></a>Call stack</h5><ul>
<li><p>首先压入一个匿名的全局调用（anonymous）<br>压栈console.log(‘global begin’)，打印后弹出栈<br>setTimeout(timer1)压栈（异步调用，需要关心内部API环境是怎么工作的），setTimeout(timer1)弹出，后面代码继续执行</p>
</li>
<li><p>setTimeout(timer2)压栈（异步调用，需要关心内部API环境是怎么工作的），setTimeout(timer2)弹出，后面代码继续执行</p>
</li>
<li><p>压栈console.log(‘global end’)，打印后弹出栈。匿名调用已经执行完成，调用栈会被清空</p>
</li>
<li><p>( 对于调用栈来说是开启新一轮的执行，执行过程于上面分析的是一致的)</p>
</li>
<li><p>将()压入栈，继续执行timer2(),打印，然后弹出栈</p>
</li>
<li><p>遇到异步调用，setTimeout(inner)压栈，（异步调用，需要关心内部API环境是怎么工作的），setTimeout(inner)弹出，后面代码继续执行</p>
</li>
</ul>
<p>打印结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console</span><br><span class="line">global begin</span><br><span class="line">global end</span><br><span class="line"></span><br><span class="line">timer2 invoke</span><br><span class="line">timer1 invoke</span><br><span class="line">inner invoke</span><br></pre></td></tr></table></figure>
<p>Web APIs（内部API环境，这里以web平台举例）</p>
<ul>
<li>为timer1 （1.8秒）函数开启了一个计数器（开始倒数），这是单独工作的，并不受当前JS线程影响</li>
<li>为timer2（1秒）函数又开启一个计数器（开始倒数），这是单独工作的，并不受当前JS线程影响</li>
<li>timer2倒计时先结束，timer2函数就会放在我们消息队列的第一位，</li>
<li>tomer1倒计时结束，timer1就会放在消息队列的第二位</li>
<li>为timerInner(1秒)函数开启了一个计数器（开始倒计时），这是单独工作的，并不受当前JS线程影响</li>
</ul>
<h4 id="事件循环和消息队列（Queue）"><a href="#事件循环和消息队列（Queue）" class="headerlink" title="事件循环和消息队列（Queue）"></a>事件循环和消息队列（Queue）</h4><p>event loop开始发挥作用（它只做一件事情：监听调用栈和消息队列，一旦调用栈中所有的任务都结束了，事件循环就会从消息队列中取出第一个回调函数，然后压如到调用栈），只不过此时我们的消息队列是空的，所以执行相当于暂停下来了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列中： timer2()    timer1() </span><br></pre></td></tr></table></figure>
<p>当消息队列中发生了变化，事件循环就会监听到，把消息队列中的第一个（timer2）取出来押入我们的调用栈，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列中：timer1()      timerInner()</span><br></pre></td></tr></table></figure>
<p>然后就是不断的重复，直到我们的调用栈和消息队列中都没有需要继续执行的任务了，整体的代码就执行结束了</p>
<h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>调用栈是一个正在执行的工作表，那消息队列就是一个待办的工作表，而js执行引擎就是先去做完调用栈中所有的任务，然后再通过事件循环，从消息队列中在取一个任务出来，继续执行，以此类推。</p>
<p>我们随时可以往消息队列中放入一些任务，这些任务会排队等候事件循环。以上就是异步调用在JavaScript中的实现过程以及基本原理，整个过程就是通过内部消息队列和事件循环去实现的。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>这之间并没有事件先后关系，他们各自都有各自的time line，例如我们的计时器，它开始之后就会直接开始倒计时，根本不过管调用栈或队列中是什么情况。这里是便于理解。</p>
<p>总结如下图</p>
<p><img src="/public/images/asyncCode1-1.png" alt="alt"></p>
<h5 id="解释如下："><a href="#解释如下：" class="headerlink" title="解释如下："></a>解释如下：</h5><p>比如JavaScript线程在某个时刻发起了一个异步调用，然后它紧接着继续执行本轮的其他任务；</p>
<p>此时异步线程会单独去执行这个异步任务，然后在执行完这个异步任务之后，会将这个异步任务的回调放入消息队列中；</p>
<p>js主线程它完成所有的任务之后，会依次执行消息队列中的任务。</p>
<h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>JavaScript 确实是单线程的，而我们的浏览器不是单线程的。我们通过JavaScript调用的某些内部的API并不是单线程的，例如我们这里的倒时器，那它内部会有一个单独的线程去负责倒数，等时间到了之后，将回调放入消息队列（也就是说这样一个事情它是由一个单独的线程去做的）。</p>
<p>我们所说的单线程指的是执行我们代码的线程是一个线程。也就是说这些内部的API它们会用单独的线程去执行这些等待的操作。</p>
<p>我们这里的同步异步，并不是指我们写代码的方式，而是指运行环境提供的API是以同步或异步模式的方式去工作。</p>
<p>对于同步模式的API的特点就是这个任务执行完，它的代码才会继续往下走（例如console.log()）;对于异步模式的API，就是下达这个任务开启过后的指令，就会继续往下执行，代码是不会在这一行等待任务的结束的（例如setTimeout()）。</p>
]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程第三篇</title>
    <url>/2022/01/22/AsyncCode/AsyncCode3/</url>
    <content><![CDATA[<blockquote>
<p>promise只是解决了回调地狱的问题，但是还是不能像同步代码那样使用。这里讲述Generator和async await的异步解决方案。</p>
</blockquote>
<h3 id="Generator-异步方案"><a href="#Generator-异步方案" class="headerlink" title="Generator 异步方案"></a>Generator 异步方案</h3><h4 id="回顾Promise函数"><a href="#回顾Promise函数" class="headerlink" title="回顾Promise函数"></a>回顾Promise函数</h4><ol>
<li><p>相比于传统回调函数的优势，Promise处理异步调用的优势：就是通过链式调用解决回调嵌套的问题。使用promise去处理异步任务的串联执行，它的表现就是一个then然后去处理一个异步调用，最终整体形成任务链条，从而实现所有任务的串联执行。但是这样写仍然会有大量的回调函数，虽然没有嵌套，但是没有同步代码的可读性。</p>
</li>
<li><p>promise 例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise chain</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;url1&#39;)</span><br><span class="line">   .then(value &#x3D;&gt; &#123;</span><br><span class="line">       return ajax(&#39;ajax&#x2F;url2&#39;)</span><br><span class="line">   &#125;)</span><br><span class="line">   .then(value &#x3D;&gt; &#123;</span><br><span class="line">       return ajax(&#39;ajax&#x2F;url3&#39;)</span><br><span class="line">   &#125;)</span><br><span class="line">   .then(value &#x3D;&gt; &#123;</span><br><span class="line">       return ajax(&#39;ajax&#x2F;url4&#39;)</span><br><span class="line">   &#125;)</span><br><span class="line">   .catch(error &#x3D;&gt; &#123;</span><br><span class="line">       console.log(error)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>传统同步代码,这种方式写的代码时最简洁也是最容易理解的。例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; like sync mode</span><br><span class="line">  try &#123;</span><br><span class="line">      const value1 &#x3D; ajax(&#39;&#x2F;api&#x2F;url1&#39;)</span><br><span class="line">      console.log(value1)</span><br><span class="line">      const value2 &#x3D; ajax(&#39;&#x2F;api&#x2F;url2&#39;)</span><br><span class="line">      console.log(value2)</span><br><span class="line">      const value3 &#x3D; ajax(&#39;&#x2F;api&#x2F;url3&#39;)</span><br><span class="line">      console.log(value3)</span><br><span class="line">      const value4 &#x3D; ajax(&#39;&#x2F;api&#x2F;url4&#39;)</span><br><span class="line">      console.log(value4)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回顾Generator-生成器-函数"><a href="#回顾Generator-生成器-函数" class="headerlink" title="回顾Generator(生成器)函数"></a>回顾Generator(生成器)函数</h4></li>
<li><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function * foo() &#123;</span><br><span class="line">    console.log(&#39;start&#39;);</span><br><span class="line">    try&#123; &#x2F;&#x2F; 捕获异常</span><br><span class="line">        const res &#x3D; yield &#39;foo&#39; </span><br><span class="line">        console.log(res); &#x2F;&#x2F; bar</span><br><span class="line">        &#x2F;&#x2F; 可以随时使用yield关键词去向外返回一个值（它并不是像return一样结束函数的执行，只是暂停函数的执行），在外面使用</span><br><span class="line">        &#x2F;&#x2F; 生成器对象的next方法，拿到这个值，</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">const generator &#x3D; foo(); &#x2F;&#x2F; 调用这个函数不会立即执行，而是生成一个生成器对象</span><br><span class="line">&#x2F;&#x2F; generator.next(); &#x2F;&#x2F; start，  调用这个生成器对象的next方法，foo函数体才会开始执行</span><br><span class="line"></span><br><span class="line">const result &#x3D; generator.next();</span><br><span class="line">console.log(result); &#x2F;&#x2F; &#123;value: &quot;foo&quot;, done: false&#125; </span><br><span class="line">&#x2F;&#x2F; done 属性用来表示这个生成器是否全部执行完了</span><br><span class="line"></span><br><span class="line">generator.next();&#x2F;&#x2F; 继续调用next方法就会从刚才yield暂停的地方继续往下执行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果在next方法中传入一个值，这个值会做为yield语句的返回值</span><br><span class="line">generator.next(&#39;bar&#39;); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果调用的是生成器对象的throw方法，那就可以在生成器函数内部去抛出一个异常，那继续往下执行时，在生成器函数内部就可以得</span><br><span class="line">&#x2F;&#x2F; 到这个异常，我们用try...catch去捕获</span><br><span class="line">generator.throw(new Error(&#39;Geneator error&#39;)) &#x2F;&#x2F; 也可以让生成器函数继续往下执行</span><br></pre></td></tr></table></figure>
<h4 id="体验Generator-函数异步方案"><a href="#体验Generator-函数异步方案" class="headerlink" title="体验Generator 函数异步方案"></a>体验Generator 函数异步方案</h4></li>
<li><p>这里可以借助yield可以暂停生成器函数执行的一个特点，去使用生成器函数实现一个更优的异步编程体验</p>
</li>
<li><p>具体实现方式:</p>
<ol>
<li>Generator 配合 Promise 的异步方案<ol>
<li>代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function * main () &#123;</span><br><span class="line">    const users &#x3D; yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;); &#x2F;&#x2F;yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;); 将promise对象返回出去</span><br><span class="line">    console.log(users, &#39;-users-&#39;) &#x2F;&#x2F; (2) [&#123;…&#125;, &#123;…&#125;] &quot;-users-&quot;</span><br><span class="line"></span><br><span class="line">    const posts &#x3D; yield ajax(&#39;api&#x2F;posts.json&#39;)</span><br><span class="line">    console.log(posts, &#39;-posts-&#39;) &#x2F;&#x2F; (2) [&#123;…&#125;, &#123;…&#125;] &quot;-posts-&quot;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> const g &#x3D; main();</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; mian 函数就会执行到第一个yield位置，也就是执行到第一个ajax调用</span><br><span class="line"> const result &#x3D; g.next();</span><br><span class="line"> &#x2F;&#x2F; result.value 就是第一个ajax返回的promise对象。然后通过result.value.then的方式去指定promise的回调</span><br><span class="line"></span><br><span class="line"> result.value.then(data &#x3D;&gt; &#123; &#x2F;&#x2F; 拿到执行结果</span><br><span class="line">     &#x2F;&#x2F;再调用next方法，将我们得到的data再次传递到生成器函数里面去。我们的main方法可以接着继续往下执行，而且我们传递进去</span><br><span class="line">     &#x2F;&#x2F; 的data会作为 我们当前这个yield的返回值</span><br><span class="line">     const result2 &#x3D; g.next(data); &#x2F;&#x2F; result2也会是promise对象</span><br><span class="line">     if (result2.done) return  &#x2F;&#x2F; 在每次调用then方法之前去判断结果的done属性是否为true</span><br><span class="line">     result2.value.then(data &#x3D;&gt; &#123;</span><br><span class="line">         const result3 &#x3D; g.next(data) </span><br><span class="line">         if (result2.done) return</span><br><span class="line">         result3.value.then(data &#x3D;&gt; &#123;</span><br><span class="line">             const result3 &#x3D; g.next(data) </span><br><span class="line">             &#x2F;&#x2F; 依次类推，如果我们多次在main函数中多次使用yield方式去返回promise对象，而且每次返回的都是promise对象，</span><br><span class="line">             &#x2F;&#x2F; 那我们完全可以不断的在结果的then中调用next，直到next所返回对象的done属性为true，也就是main函数完全执行</span><br><span class="line">             &#x2F;&#x2F; 结束</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 这里我们完全可以使用递归的方式去不断迭代，直到我们返回结果的done属性为true，也就是main函数执行结束，去结束我们的递归</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>递归执行Generator 函数，<ol>
<li>示例代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function * main () &#123;</span><br><span class="line">   try&#123; &#x2F;&#x2F; 捕获异常</span><br><span class="line">    const users &#x3D; yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;); &#x2F;&#x2F;yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;); 将promise对象返回出去</span><br><span class="line">    console.log(users, &#39;-users-&#39;) &#x2F;&#x2F; (2) [&#123;…&#125;, &#123;…&#125;] &quot;-users-&quot;</span><br><span class="line"> </span><br><span class="line">    const posts &#x3D; yield ajax(&#39;api&#x2F;posts.json&#39;)</span><br><span class="line">    console.log(posts, &#39;-posts-&#39;) &#x2F;&#x2F; (2) [&#123;…&#125;, &#123;…&#125;] &quot;-posts-&quot;</span><br><span class="line"> </span><br><span class="line">    const posts11 &#x3D; yield ajax(&#39;api&#x2F;posts11.json&#39;)</span><br><span class="line">    console.log(posts11, &#39;-posts11-&#39;) &#x2F;&#x2F; 失败</span><br><span class="line">   &#125; catch (e) &#123;</span><br><span class="line">       console.log(e) &#x2F;&#x2F;GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;posts11.json 404 (Not Found)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">const g &#x3D; main();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用递归的方式去实现一个更通用的生成器函数的执行器</span><br><span class="line">function handleResult (result) &#123;</span><br><span class="line">    if (result.done) return ; &#x2F;&#x2F; 生成器函数结束</span><br><span class="line">    result.value.then(data &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;g.next(data) 这个next方法返回的又会是下一个result，那我们将result再次交给handleResult函数进行递归</span><br><span class="line">        handleResult(g.next(data))</span><br><span class="line">    &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 处理失败的回调</span><br><span class="line">        g.throw(error) &#x2F;&#x2F; 调用生成器对象的throw方法，让生成器函数在继续执行时得到一个异常</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 那我们只需要调用handleResult，然后传入第一个的next结果就可以了,只要我们生成器函数不结束，就会一直递归下去</span><br><span class="line">handleResult(g.next())</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>上面的完全可以复用，我们将其封装成一个公用的函数–生成器函数执行器，在社区中更完善的库（<a href="https://github.com/tj/co%EF%BC%89">https://github.com/tj/co）</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function co (generator) &#123;</span><br><span class="line">    const g &#x3D; generator();</span><br><span class="line">    function handleResult (result) &#123;</span><br><span class="line">        if (result.done) return ;</span><br><span class="line">        result.value.then(data &#x3D;&gt; &#123;</span><br><span class="line">            handleResult(g.next(data))</span><br><span class="line">        &#125;, error &#x3D;&gt; &#123; </span><br><span class="line">            g.throw(error) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    handleResult(g.next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(main)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用generator方案最明显的变化就是让我们的异步调用再次回归到扁平化。</strong>但是在日常开发中还是使用async/await方式</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="Async-Await-语法糖"><a href="#Async-Await-语法糖" class="headerlink" title="Async/ Await 语法糖"></a>Async/ Await 语法糖</h3><blockquote>
<p>语言层面的异步编程标准<br>有了Generator之后，JavaScript中的异步编程基本上与同步代码有类似体验了，但是使用Generator这种异步方案，我们还需要自己手动实现一个执行器函数(就像上面例子中的co函数一样)，会比较麻烦。<br>在ES2017 标准中新增了async函数，它同样提供了这种扁平化的异步编程体验，而且它是语言层面标准的异步编程语法，会更加方便。其实async函数就是生成器函数一种更方便的语法糖，语法上生成器函数与async函数是非常相似的，</p>
</blockquote>
<ol>
<li>例子如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> async function main () &#123;</span><br><span class="line">    try&#123; &#x2F;&#x2F; 捕获异常</span><br><span class="line">     const users &#x3D; await ajax(&#39;&#x2F;api&#x2F;users.json&#39;); &#x2F;&#x2F;yield ajax(&#39;&#x2F;api&#x2F;users.json&#39;); 将promise对象返回出去</span><br><span class="line">     console.log(users, &#39;-users-&#39;) &#x2F;&#x2F; (2) [&#123;…&#125;, &#123;…&#125;] &quot;-users-&quot;</span><br><span class="line">  </span><br><span class="line">     const posts &#x3D; await ajax(&#39;api&#x2F;posts.json&#39;)</span><br><span class="line">     console.log(posts, &#39;-posts-&#39;) &#x2F;&#x2F; (2) [&#123;…&#125;, &#123;…&#125;] &quot;-posts-&quot;</span><br><span class="line">  </span><br><span class="line">     const posts11 &#x3D; await ajax(&#39;api&#x2F;posts11.json&#39;)</span><br><span class="line">     console.log(posts11, &#39;-posts11-&#39;) &#x2F;&#x2F; 失败</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        console.log(e) &#x2F;&#x2F;GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;posts11.json 404 (Not Found)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; co(main)</span><br><span class="line">const promise &#x3D; main();&#x2F;&#x2F; 执行这个函数内部的执行过程与我们刚刚Generator函数是完全一样的，效果也是完全一样的</span><br><span class="line"></span><br><span class="line">promise.then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;all completed&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">相比于Generator，async最大的好处就是：它不需要再去配合类似co这样的执行器，因为它是语言层面的标准异步编程语法，其次async函数它可以返回promise对象，这样更利于我们对整体代码进行控制。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：</p>
<ol>
<li>相比于Generator，async最大的好处就是：<strong>它不需要再去配合类似co这样的执行器，因为它是语言层面的标准异步编程语法，其次async函数它可以返回promise对象，这样更利于我们对整体代码进行控制。</strong></li>
<li><strong>注意：async中使用await关键词只能出现在async函数内部，它不能直接在外部也就是顶层作用域去使用。</strong></li>
</ol>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程第二篇</title>
    <url>/2021/12/08/AsyncCode/AsyncCode2/</url>
    <content><![CDATA[<blockquote>
<p>单线程 JavaScript 异步方案。本篇讲述回调函数，以及使用promise来处理异步的方案。</p>
</blockquote>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><ol>
<li><p>概念：由调用者定义，交给执行者执行的函数就叫回调函数。除了回调函数参数这种方式以外，还有几种常见实现异步方式，例如：事件机制、发布订阅。个人认为这些也都是是基于回调函数上的一些变体罢了。</p>
</li>
<li><p>用法：把函数作为参数去传递，但这写代码特别不利于阅读，整个执行顺序会非常混乱。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo (callback) &#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    callback()</span><br><span class="line">&#125;, 3000)</span><br><span class="line">&#125;</span><br><span class="line">foo (function() &#123;</span><br><span class="line">console.log(&#39;这是一个回调函数&#39;);</span><br><span class="line">console.log(&#39;调用者定义这个函数，执行者执行这个函数&#39;);</span><br><span class="line">console.log(&#39;其实就是调用者告诉执行者异步任务结束后应该做什么&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数是所有异步编程方案的根基。</p>
<p>实现异步编程的根本方式：其实所有的异步编程方案，他的根本都是回调函数。</p>
<ol start="3">
<li>理解：回调函数可以理解为一件你想要做的事情，你明确知道这件事情怎么一步一步往下做，但是你不知道这件事情所依赖的任务什么时候完成，所以最好的办法就是把你这件事情的步骤写到一个函数当中，交给任务的执行者，那这个异步任务的执行者它是知道这个任务是什么时候结束的，它可以在任务结束之后去帮你执行你想要的事情。例子：比如要刷漆，需要买油漆。。。</li>
</ol>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="promise-概述"><a href="#promise-概述" class="headerlink" title="promise 概述"></a>promise 概述</h4><ol>
<li><p>概念：一种更优的异步编程统一方案。</p>
</li>
<li><p>原因：直接使用传统回调方式去完成复杂的异步流程就无法避免大量的回调函数嵌套，也就是我们所说的回调地狱。为了避免回调地狱的问题，CommonJS社区提出了Promise的规范，目的就是为异步编程提供一种更合理，更强大的统一解决方案。在ES2015中被标准化，成为语言规范。</p>
</li>
<li><p>Promise：所谓Promise就是一个对象，用来表示一个异步任务最终结束之后，它究竟是成功还是失败。就像是内部对外界做出的一个承诺。开始这个承诺处于待定状态（英文叫Pending），最终有可能成功（英文叫Fulfilled），也有可能失败（英文叫Rejected）。结束之后，承诺最终不管是达成还是失败，你都会有相对应的反应。也就是在承诺状态确定之后，都会有相对应的任务会被自动执行。比如Ajax请求，请求成功就调onFulfilled回调，请求失败就调onRejected回调。</p>
<ol>
<li>承诺的特点：一旦明确了结果过后，就不可能在发生改变。</li>
<li>如下图：<br><img src="/public/images/asyncCode2-1.png" alt="alt"> </li>
</ol>
</li>
</ol>
<h4 id="Promise-基本用法"><a href="#Promise-基本用法" class="headerlink" title="Promise 基本用法"></a>Promise 基本用法</h4><ol>
<li>代码示例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise 是es2015 提供的一个全局类型</span><br><span class="line"> const promise &#x3D; new Promise(function(resolve,reject) &#123;</span><br><span class="line">     &#x2F;&#x2F; 这个函数在构造Promise中被同步执行，这里用于“兑现”承诺</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 一般我们将异步任务操作的结果通过resolve的参数传递出去</span><br><span class="line">     resolve(100);&#x2F;&#x2F;承诺达成，作用：将这个promise对象的状态修改为fulfilled（成功）</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 失败的参数，一般我们传递失败的对象用来表示这个承诺为什么失败</span><br><span class="line">     &#x2F;&#x2F; reject(new Error(&#39;promise reject&#39;));&#x2F;&#x2F; 承诺失败，作用：将这个promise对象的状态修改为rejected（失败）</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;因为Promise的状态一般确定了就不能修改了，所以在这个函数中只能调用这二者中其一</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 即便我们的promise中，没有任何的异步操作，then方法中指定的回调函数仍然会进入到回调队列中排队。也就是说，等待这里同步代码全部执行完了，then方法中的才会执行</span><br><span class="line"> promise.then(function(value) &#123;&#x2F;&#x2F; onFulfilled回调函数</span><br><span class="line">     console.log(&#39;resolved&#39;, value);</span><br><span class="line"> &#125;,function() &#123; &#x2F;&#x2F; onRejcted回调函数</span><br><span class="line">     console.log(&#39;rejected&#39;, error);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> console.log(&#39;end&#39;);</span><br><span class="line"> &#x2F;&#x2F; end</span><br><span class="line"> &#x2F;&#x2F; resolved 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Promise-使用案例"><a href="#Promise-使用案例" class="headerlink" title="Promise 使用案例"></a>Promise 使用案例</h4><h5 id="使用promise-封装ajax"><a href="#使用promise-封装ajax" class="headerlink" title="使用promise 封装ajax"></a>使用promise 封装ajax</h5><ol>
<li><p>代码示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url); &#x2F;&#x2F;设置请求方式与请求地址</span><br><span class="line">    &#x2F;&#x2F;设置请求返回的类型为json，这样请求完成返回的数据就不是字符串，而是json对象，es2015新特性</span><br><span class="line">    xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">    &#x2F;&#x2F; 请求完成之后（readyState&#x3D;4），触发的事件，html5添加的新事件</span><br><span class="line">    xhr.onload &#x3D; function () &#123;</span><br><span class="line">      if(this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;).then(function(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;,function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Promise-常见误区"><a href="#Promise-常见误区" class="headerlink" title="Promise 常见误区"></a>Promise 常见误区</h5></li>
<li><p>通过前面的演示发现，从表象上来看Promise的本质也就是使用回调函数方式去定义异步任务结束后所需要执行的任务。只不过这里的回调函数是通过then方法传递进去的，只不过promise将我们的回调分成了两种：成功过后的回调（onFulfilled），失败过后的回调（onRejected）。</p>
<ol>
<li>示例代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;,function onReject () &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error)</span><br><span class="line">&#125;)</span><br><span class="line"> 嵌套使用的方式是使用Promise 最常见的错误</span><br></pre></td></tr></table></figure></li>
<li>错误使用代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&quot;&#x2F;api&#x2F;urls.json&quot;).then(function (urls) &#123;</span><br><span class="line">  ajax(urls.users).then(function(users)&#123;</span><br><span class="line">    ajax(urls.users).then(function(users)&#123;</span><br><span class="line">      ajax(urls.users).then(function(users)&#123;</span><br><span class="line">        ajax(urls.users).then(function(users)&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">正确做法：借助于Promise then 方法链式调用的特点，尽可能保证异步任务的扁平化Promise 链式调用</span><br></pre></td></tr></table></figure>
<h5 id="Promise-链式调用"><a href="#Promise-链式调用" class="headerlink" title="Promise 链式调用"></a>Promise 链式调用</h5></li>
</ol>
</li>
<li><p>Promise的链式调用能最大程度的避免回调嵌套。</p>
</li>
<li><p>特点</p>
<ol>
<li>Promise 对象的 then 方法会返回一个全新的 Promise 对象，所以我们可以使用链式调用的方式添加then方法</li>
<li>后面的 then 方法 就是在为上一个 then 返回的 Promise 注册回调</li>
<li>前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数</li>
<li>如果回调中返回的是Promise对象，那后面 then 方法的回调会等待这个promise的结束。也就是说后面的promise方法，也就是为我们返回的promise对象，去注册了对应的回调。</li>
</ol>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;);</span><br><span class="line">var promise2 &#x3D; promise.then( &#x2F;&#x2F;then方法作用：为promise对象，去添加状态明确后的回调函数</span><br><span class="line">  function onFulfilled (value) &#123;&#x2F;&#x2F; 成功后的回调</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  function onRejected(error)&#123;&#x2F;&#x2F; 失败后的回调，可省略</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(promise2 &#x3D;&#x3D;&#x3D; promise); &#x2F;&#x2F; false 返回的是一个全新的promise对象</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回一个全新Promise对象的目的是为了实现一个promise链，一个承诺结束之后，返回一个新的承诺，每个承诺都可以负责一个异步任务相互之</span><br><span class="line">&#x2F;&#x2F; 间没什么影响。意味着，如果我们不断调用链式then方法，这里的每一个then方法实际上是为了上一个then方法返回的promise对象去添加状态</span><br><span class="line">&#x2F;&#x2F; 明确后的回调</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里promise 会依次执行: 1111 2222 3333 4444 5555</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(1111);</span><br><span class="line">  &#x2F;&#x2F; 在回调中手动返回一个promise对象，那下一个then方法实际上是为这个promise对象去添加状态明确过后的回调。可以避免不必要的回调嵌套</span><br><span class="line">  &#x2F;&#x2F; return ajax(&#39;api&#x2F;urls.json&#39;);&#x2F;&#x2F; 意思是：这里的ajax调用之后</span><br><span class="line">&#125;)&#x2F;&#x2F; &#x3D;&gt; Promise</span><br><span class="line">.then(function(value) &#123;&#x2F;&#x2F; 会自动执行这个方法中的回调</span><br><span class="line">  console.log(2222);</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)&#x2F;&#x2F; &#x3D;&gt; Promise</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(3333);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(4444);</span><br><span class="line">  return &#39;foo&#39;; &#x2F;&#x2F; 如果我们返回的不是一个promise而是一个普通的值，这个值就会作为这个then方法返回的这个promise中的值，在下一个then</span><br><span class="line">  &#x2F;&#x2F; 方法接收的回调参数实际上拿到就是这个值，若我们没有返回任何值，那默认返回就是undefined</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(5555);</span><br><span class="line">  console.log(value); &#x2F;&#x2F; foo</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有多个连续的任务，我们就可以使用这种链式调用的方式去避免回调的嵌套，从而尽量保证我们的代码的扁平化</span><br></pre></td></tr></table></figure>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5></li>
<li><p>处理异常的两种方式</p>
<ol>
<li>通过then方法第二个参数去指定的失败的回调函数</li>
<li>代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line"> .then(function onFulfilled(value) &#123;</span><br><span class="line">     console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line"> &#125;,function onRejected(error) &#123;</span><br><span class="line">     &#x2F;&#x2F; promise 的结果失败，就会调用这个onRejected回调函数</span><br><span class="line">     &#x2F;&#x2F; 在promise执行过程中出现了异常，或者我们手动抛出异常也会执行这个回调函数</span><br><span class="line">     console.log(&#39;onRejected&#39;, error);</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; onRejected回调实际上是为promise中的异常去做一些处理，在promise失败或者出现异常时，它都会被执行</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>用catch方法去指定失败回调更为常见，因为这种方式更适合链式调用</p>
<ol>
<li>代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function onRejcted(error) &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);&#x2F;&#x2F; 这里的catch实际上时then方法的别名，因为我们调用它，相当于调用了then方法，不过</span><br><span class="line">&#x2F;&#x2F; 第一个参数传递的是undefined，第二个是onRejected回调函数</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;)</span><br><span class="line">.then(undefined, function onRejcted(error) &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>这两种方式的差异</p>
</li>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 两者的差异对比</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">    return ajax(&#39;error-url&#39;);</span><br><span class="line">&#125;, function onRejcted(error) &#123; &#x2F;&#x2F; 没有捕获到 ajax(&#39;error-url&#39;) 发生的异常</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users11.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">    return ajax(&#39;error-url&#39;);</span><br><span class="line">&#125;) &#x2F;&#x2F; &#x3D;&gt; Promsie &#123;&#125;</span><br><span class="line">.catch(function onRejcted(error) &#123; &#x2F;&#x2F; 可以正常捕获到 ajax(&#39;error-url&#39;) 发生的异常</span><br><span class="line">    &#x2F;&#x2F; 原因：我们这个失败回调，它是注册在上一个（也就是then方法返回的）promise对象上</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>因为每个then方法它返回的都是一个全新的promise对象，也就是说，我们在后面用链式调用的方式，调用的catch实际上是给前面的then方法返回的promise对象去指定失败回调，并不是直接去给第一个promise对象所指定的。只不过因为这是同一个promise链条，那前面promise上的异常会一直往后传递，所以我们在这里才能捕获到第一个promise中的异常。</p>
</li>
<li><p>而通过then方法第二个参数去指定的失败的回调函数，它只是给第一个promise对象指定的，也就是说它只能捕获到这个promise对象的异常。</p>
</li>
<li><p>具体表象上的差异</p>
<ol>
<li>如果我们在then方法中返回了第二个promise，而且这个promise在执行中出现了异常，那我们使用then方法的第二个参数注册的回调，它是捕获不到第二个promise的异常的，因为它只是给第一个promise注册的失败回调。</li>
<li><strong>所以对于链式调用的情况下，建议使用第二种（catch）方式，去分开指定成功回调和失败回调。因为promise链条上任何一个异常都会被一直向后传递直至被捕获。</strong>也就是说，这种方式更像是为整个promise链条注册的失败回调，相对说更通用。</li>
</ol>
</li>
<li><p>除此之外，可以在全局对象上注册<strong>unhandledrejecction</strong>事件，去处理那些我们在代码中没有被手动捕获的promise异常。</p>
<ol>
<li>在浏览器中，我们将事件注册在window对象上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#39;unhandledrejection&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">   const &#123;reason, promise&#125; &#x3D; event</span><br><span class="line">   console.log(reason, promise);</span><br><span class="line">   &#x2F;&#x2F; reason &#x3D;&gt; Promise 失败原因，一般是一个错误对象</span><br><span class="line">   &#x2F;&#x2F; promise &#x3D;&gt; 出现异常的 Promise 对象</span><br><span class="line">   event.preventDefault();</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li>
<li>在node环境中，我们需要将事件注册到process对象上,不过事件是驼峰命名的，参数也不太相同<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.on(&#39;unhandledrejection&#39;, (reason, promise)&#x3D;&gt; &#123;</span><br><span class="line">   console.log(reason, promise);</span><br><span class="line">   &#x2F;&#x2F; reason &#x3D;&gt; Promise 失败原因，一般是一个错误对象</span><br><span class="line">   &#x2F;&#x2F; promise &#x3D;&gt; 出现异常的 Promise 对象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>这种全局捕获的方式不推荐使用，更合适的方法：<strong>在代码中明确捕获每一个可能的异常，而不是丢给全局统一处理。</strong></li>
</ol>
</li>
</ol>
<h5 id="Promise-静态方法"><a href="#Promise-静态方法" class="headerlink" title="Promise 静态方法"></a>Promise 静态方法</h5><ol>
<li><p>Promise.resolve()</p>
<ol>
<li>作用：快速将一个值转化为promise对象<ol>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)&#x2F;&#x2F;直接返回一个状态为fulfilled的promise对象,这个&#39;foo&#39;就会作为promise 对象所返回的值</span><br><span class="line"> .then(function(value) &#123;</span><br><span class="line">     console.log(value);&#x2F;&#x2F; foo</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 上面等价于下面的</span><br><span class="line"> new Promise(function(resolve, reject)&#123;</span><br><span class="line">     resolve(&#39;foo&#39;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Promise.resolve方法如果接收到的是另一个promise对象，这个promise对象则会原样返回，也就是我们用Promise.resolve去包裹一个promise，得到的是被包裹的那个promise<ol>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;);</span><br><span class="line">var promise2 &#x3D; Promise.resolve(promise);</span><br><span class="line">console.log(promise &#x3D;&#x3D;&#x3D; promise2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>若我们传入的是一个对象，这个对象也有与promise一样的then方法，这样的对象也可以作为一个promise对象被执行，在后面的then方法中也能拿到这里所对应传入的值<ol>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(</span><br><span class="line"> &#x2F;&#x2F;这种带有then方法的对象实现了thenable接口，也就是说它是一个可以被then的对象。支持这种对象的原因，是因为在promise没有普及之前，我们都是使用第三方库去实现promise，如果我们想将第三方的promise对象换成原生的promise，就可以借助这样的机制，因为在第三方promise对象中也有相同的这种then方法，那就可以通过Promise.resolve将其转换成原生的promise对象</span><br><span class="line"> &#123;</span><br><span class="line">     then:function(onFulfilled, onRejected)&#123;</span><br><span class="line">         onFulfilled(&#39;foo&#39;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> .then(function(value)&#123;</span><br><span class="line">     console.log(value);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Promise.reject()</p>
<ol>
<li>作用：快速创建一个失败的promise对象。</li>
<li>参数：无论我们传入什么参数，都会作为promise失败的理由（失败的原因）</li>
<li>示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject(new Error(&#39;rejected&#39;))</span><br><span class="line">  .catch(function(error)&#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Promise.reject(&#39;anything&#39;)</span><br><span class="line">  .catch(function(error)&#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Promise-并行执行"><a href="#Promise-并行执行" class="headerlink" title="Promise 并行执行"></a>Promise 并行执行</h5></li>
</ol>
</li>
<li><p>前面的操作都是通过promise去串联多个异步任务，也就是一个任务之后，再去开启下一个任务。相对于传统的回调方式Promise提供了更扁平的异步体验。如果需要同时并行执行多个异步任务（比如请求多个接口，且他们之间没有相互依赖），promise也可以提供更完善的体验。</p>
</li>
<li><p>Promise.all()</p>
<ol>
<li>作用：可以将多个Promise合并为一个Promise统一去管理。</li>
<li>Promise.all():参数是数组，里面是一个个promise对象（每个promise对象可看作是一个异步任务），返回一个全新的promise对象。当内部所有的promise完成之后，我们所返回的这个全新的promise才会完成，此时这个promise对象拿到的结果就是数组，这个数组包含每个异步任务执行后的结果</li>
<li><strong>注意：在这个任务过程中，只有这两个任务都成功结束了，这个新的promise才会成功结束，如果这里有其中一个任务结束了，那这个promise就会以失败结束。</strong></li>
<li>示例代码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise.all()能够很好的处理这种并行的异步请求</span><br><span class="line">var promise &#x3D; Promise.all([</span><br><span class="line">    ajax(&#39;&#x2F;api&#x2F;users.json&#39;),</span><br><span class="line">    ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)</span><br><span class="line">]);</span><br><span class="line">promise.then(function (values)&#123;</span><br><span class="line">    console.log(values); &#x2F;&#x2F; (2) [Array(2), Array(2)]</span><br><span class="line">&#125;).catch(function (error)&#123;</span><br><span class="line">    console.log(error); &#x2F;&#x2F; GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;posts11.json 404 (Not Found)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>综合使用串联和并联这两种方式</p>
<ol>
<li>示例代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)</span><br><span class="line"> .then(value &#x3D;&gt; &#123;</span><br><span class="line">     const urls &#x3D; Object.values(value);</span><br><span class="line">     const task &#x3D; urls.map(url &#x3D;&gt; ajax(url));&#x2F;&#x2F; 返回的task是promise对象数组</span><br><span class="line">     return Promise.all(task);</span><br><span class="line"> &#125;)</span><br><span class="line"> .then(values &#x3D;&gt; &#123;</span><br><span class="line">     console.log(values);&#x2F;&#x2F; (2) [Array(2), Array(2)]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Promise.race()</p>
<ol>
<li>作用：也可以将多个Promise对象组合成一个全新的Promise对象。</li>
<li>示例代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)</span><br><span class="line">const timeout &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        reject(new Error(&#39;timeout&#39;))</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 效果：如果500毫秒内请求完成了，就可以正常得到响应结果，如果500毫秒之后，请求就无法将请求返回因为在500毫秒后我们的第二个promise会以失败方式结束，而race方法就是以第一个结束的promise为准</span><br><span class="line">Promise.race([</span><br><span class="line">    request,</span><br><span class="line">    timeout</span><br><span class="line">])</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(value) &#x2F;&#x2F; Array(2)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">    console.log(error) &#x2F;&#x2F; Error: timeout</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Promise.all(）与 Promise.race()的区别</p>
</li>
<li><p><strong><code>Promose.all()</code> 等待所有的任务结束后才会结束（所有的任务成功结束，才会成功结束），<code>Promise.race()</code>只会等待第一个结束的任务，也就是说只要任何一个任务完成了，那我们这个返回的新的Promise也就会完成</strong></p>
</li>
</ol>
<h5 id="Promise-执行时序（宏任务-VS-微任务）"><a href="#Promise-执行时序（宏任务-VS-微任务）" class="headerlink" title="Promise 执行时序（宏任务 VS 微任务）"></a>Promise 执行时序（宏任务 VS 微任务）</h5><ol>
<li>正如我们开始介绍的，即便我们的<code>promise</code>中没有任何的异步操作，它的会回调函数也会进入到回调队列中去排队，也就是说，我们必须等待当前所有的同步代码执行完了之后才会去执行<code>promise</code>中的回调（这句话不是很严谨）。</li>
<li>生活小场景：去银行办理存款业务，办完存款后，我突然想办一张信用卡，然后告诉银行柜员我的需求，银行柜员为了提高效率和用户体验，不会让我重新排队，它能够办理就帮我办理了。那这种行为不属于插队，只是我在完成主要任务后临时多了一些小插曲。在例子中，我们排队办理业务就是回调队列中等待执行的任务一样，队伍中每一个人对应回调队列中的一个任务（<strong>回调队列中的任务称之为宏任务</strong>），宏任务执行过程中可以临时加上一些额外的需求，这些临时的需求可以选择作为一个新的宏任务进到回调队列中排队（例如<code>setTimeout</code>回调就会作为宏任务再次在队列中排队），也可以作为当前任务的<strong>微任务，直接在当前任务结束过后立即执行</strong>，而不是直接到队伍后面排队（这也是宏任务与微任务之间的差异。</li>
<li><strong>Promise 的回调会作为微任务执行，在本轮调用的末尾去自动执行。</strong></li>
<li>微任务：提高整体的响应能力。</li>
<li><strong>目前绝大多数异步调用都是作为宏任务执行，而Promise对象 和 MutationObserver对象 以及 node中process.nextTick，他们会作为微任务直接在本轮调用的末尾直接执行了。</strong></li>
</ol>
]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
</search>
