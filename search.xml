<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6 之 Promise</title>
    <url>/2020/07/29/promise/</url>
    <content><![CDATA[<blockquote>
<p>Promis是一种更优的异步编程统一方案。<br>它出现的原因是：直接使用传统回调方式去完成复杂的异步流程就无法避免大量的回调函数嵌套，也就是我们所说的回调地狱。为了避免回调地狱的问题，CommonJS社区提出了Promise的规范，目的就是为异步编程提供一种更合理，更强大的统一解决方案。在ES2015中被标准化，成为语言规范。</p>
</blockquote>
<a id="more"></a>
<h4 id="Promise概述"><a href="#Promise概述" class="headerlink" title="Promise概述"></a>Promise概述</h4><p>Promise：所谓Promise就是一个对象，用来表示一个异步任务最终结束之后，它究竟是成功还是失败。就像是内部对外界做出的一个承诺。开始这个承诺处于待定状态（英文叫Pending），最终有可能成功（英文叫Fulfilled），也有可能失败（英文叫Rejected）。结束之后，承诺最终不管是达成还是失败，你都会有相对应的反应。也就是在承诺状态确定之后，都会有相对应的任务会被自动执行。比如Ajax请求，请求成功就调onFulfilled回调，请求失败就调onRejected回调。</p>
<p>特点：一旦明确了结果过后，就不可能在发生改变</p>
<img src="/2020/07/29/promise/promiseStates.png" class title="This is an promiseStates image">

<h4 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h4><p>Promise是ES2015提供的一个全局类型。</p>
<p>这个函数在构造Promise中被同步执行，这里用于“兑现”承诺。一般我们将异步任务操作的结果通过resolve的参数传递出去，这个promise对象的状态会修改为fulfilled（成功）；reject用来传递失败的，这个promise对象的状态会修改为rejected（失败）。</p>
<p>因为Promise的状态一般确定了就不能修改了，所以在这个函数中只能调用这二者中其一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promise &#x3D; new Promise(function(resolve,reject) &#123;</span><br><span class="line">    resolve(100);&#x2F;&#x2F;承诺达成</span><br><span class="line">    &#x2F;&#x2F; 失败的参数，一般我们传递失败的对象用来表示这个承诺为什么失败</span><br><span class="line">    reject(new Error(&#39;promise reject&#39;));&#x2F;&#x2F; 承诺失败</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>即便我们的promise中，没有任何的异步操作，then方法中指定的回调函数仍然会进入到回调队列中排队。也就是说，等待这里同步代码全部执行完了，then方法中的才会执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;&#x2F;&#x2F; onFulfilled回调函数</span><br><span class="line">  console.log(&#39;resolved&#39;, value);</span><br><span class="line">&#125;,function() &#123; &#x2F;&#x2F; onRejcted回调函数</span><br><span class="line">  console.log(&#39;rejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;end&#39;);</span><br></pre></td></tr></table></figure>
<p>调用结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">resolved 100</span><br></pre></td></tr></table></figure>
<h4 id="Promise使用案例"><a href="#Promise使用案例" class="headerlink" title="Promise使用案例"></a>Promise使用案例</h4><p>使用Promise封装Ajax</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ajax(url) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">    xhr.open(&quot;GET&quot;, url); &#x2F;&#x2F;设置请求方式与请求地址</span><br><span class="line">    &#x2F;&#x2F;设置请求返回的类型为json，这样请求完成返回的数据就不是字符串，而是json对象，es2015新特性</span><br><span class="line">    xhr.responseType &#x3D; &quot;json&quot;;</span><br><span class="line">    &#x2F;&#x2F; 请求完成之后（readyState&#x3D;4），触发的事件，html5添加的新事件</span><br><span class="line">    xhr.onload &#x3D; function () &#123;</span><br><span class="line">      if(this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;).then(function(res) &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;,function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise常见误区"><a href="#Promise常见误区" class="headerlink" title="Promise常见误区"></a>Promise常见误区</h4><p>通过前面的演示发现，从表象上来看Promise的本质也就是使用回调函数方式去定义异步任务结束后所需要执行的任务。只不过这里的回调函数是通过then方法传递进去的，只不过promise将我们的回调分成了两种：成功过后的回调（onFulfilled），失败过后的回调（onRejected）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function onFulfilledc(value) &#123;</span><br><span class="line">  console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;,function onReject () &#123;</span><br><span class="line">  console.log(&#39;onRejected&#39;, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>嵌套使用的方式是使用Promise最常见的错误。错误使用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&quot;&#x2F;api&#x2F;urls.json&quot;).then(function (urls) &#123;</span><br><span class="line">  ajax(urls.users).then(function(users)&#123;</span><br><span class="line">    ajax(urls.users).then(function(users)&#123;</span><br><span class="line">      ajax(urls.users).then(function(users)&#123;</span><br><span class="line">        ajax(urls.users).then(function(users)&#123;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正确做法：借助于Promise.then方法链式调用的特点，尽可能保证异步任务的扁平化</p>
</blockquote>
<h4 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h4><p>Promise的链式调用能最大程度的避免回调嵌套。</p>
<ul>
<li>特点：<ul>
<li>Promise对象的then方法会返回一个全新的Promise对象，所以我们可以使用链式调用的方式添加then方法。</li>
<li>后面的then方法就是在为上一个then返回的Promise注册回调。</li>
<li>前面then方法中回调函数的返回值会作为后面then方法回调的参数。</li>
<li>如果回调中返回的是Promise对象，那后面then方法的回调会等待这个promise的结束。也就是说后面的promise方法，也就是为我们返回的promise对象，去注册了对应的回调。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;);</span><br><span class="line">var promise2 &#x3D; promise.then( &#x2F;&#x2F;then方法作用：为promise对象，去添加状态明确后的回调函数</span><br><span class="line">  function onFulfilled (value) &#123;&#x2F;&#x2F; 成功后的回调</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  function onRejected(error)&#123;&#x2F;&#x2F; 失败后的回调，可省略</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">console.log(promise2 &#x3D;&#x3D;&#x3D; promise); &#x2F;&#x2F; false 返回的是一个全新的promise对象</span><br></pre></td></tr></table></figure>
<p>返回一个全新Promise对象的目的是为了实现一个promise链，一个承诺结束之后，返回一个新的承诺，每个承诺都可以负责一个异步任务相互之间没什么影响。意味着，如果我们不断调用链式then方法，这里的每一个then方法实际上是为了上一个then方法返回的promise对象去添加状态明确后的回调</p>
<p>如果我们返回的不是一个promise而是一个普通的值，这个值就会作为这个then方法返回的这个promise中的值，在下一个then方法接收的回调参数实际上拿到就是这个值，若我们没有返回任何值，那默认返回就是undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(1111);</span><br><span class="line">  &#x2F;&#x2F; 在回调中手动返回一个promise对象，那下一个then方法实际上是为这个promise对象去添加状态明确过后的回调。可以避免不必要的回调嵌套</span><br><span class="line">  &#x2F;&#x2F; return ajax(&#39;api&#x2F;urls.json&#39;);&#x2F;&#x2F; 意思是：这里的ajax调用之后</span><br><span class="line">&#125;)  &#x2F;&#x2F; &#x3D;&gt; Promise</span><br><span class="line">.then(function(value) &#123;&#x2F;&#x2F; 会自动执行这个方法中的回调</span><br><span class="line">  console.log(2222);</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;)  &#x2F;&#x2F; &#x3D;&gt; Promise</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(3333);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(4444);</span><br><span class="line">  return &#39;foo&#39;;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">  console.log(5555);</span><br><span class="line">  console.log(value); &#x2F;&#x2F; foo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果有多个连续的任务，我们就可以使用这种链式调用的方式去避免回调的嵌套，从而尽量保证我们的代码的扁平化。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>处理异常的两种方式：</p>
<ol>
<li>通过then方法第二个参数去指定的失败的回调函数;</li>
<li>用catch方法去指定失败回调。</li>
</ol>
<h5 id="通过then方法第二个参数去指定的失败的回调函数"><a href="#通过then方法第二个参数去指定的失败的回调函数" class="headerlink" title="通过then方法第二个参数去指定的失败的回调函数"></a>通过then方法第二个参数去指定的失败的回调函数</h5><p>onRejected回调实际上是为promise中的异常去做一些处理，在promise失败或者出现异常时，它都会被执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;,function onRejected(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; promise 的结果失败，就会调用这个onRejected回调函数在promise执行过程中出现了异常，或者我们手动抛出异常也会执行这个回调函数</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="用catch方法去指定失败回调"><a href="#用catch方法去指定失败回调" class="headerlink" title="用catch方法去指定失败回调"></a>用catch方法去指定失败回调</h5><p>用catch方法去指定失败回调更为常见，因为这种方式更适合链式调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function onRejcted(error) &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 这里的catch实际上时then方法的别名，因为我们调用它，相当于调用了then方法，不过第一个参数传递的是undefined，第二个是onRejected回调函数</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users1111.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">&#125;)</span><br><span class="line">.then(undefined, function onRejcted(error) &#123;</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="这两种方式的差异"><a href="#这两种方式的差异" class="headerlink" title="这两种方式的差异"></a>这两种方式的差异</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 两者的差异对比</span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">    return ajax(&#39;error-url&#39;);</span><br><span class="line">&#125;, function onRejcted(error) &#123; &#x2F;&#x2F; 没有捕获到 ajax(&#39;error-url&#39;) 发生的异常</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ajax(&#39;&#x2F;api&#x2F;users11.json&#39;)</span><br><span class="line">.then(function onFulfilled(value) &#123;</span><br><span class="line">    console.log(&#39;onFulfilled&#39;, value);</span><br><span class="line">    return ajax(&#39;error-url&#39;);</span><br><span class="line">&#125;) &#x2F;&#x2F; &#x3D;&gt; Promsie &#123;&#125;</span><br><span class="line">.catch(function onRejcted(error) &#123; </span><br><span class="line">  &#x2F;&#x2F; 可以正常捕获到 ajax(&#39;error-url&#39;) 发生的异常。原因：我们这个失败回调，它是注册在上一个（也就是then方法返回的）promise对象上</span><br><span class="line">    console.log(&#39;onRejected&#39;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>那为什么会出现上面那种情况呢？</p>
<ul>
<li>因为每个then方法它返回的都是一个全新的promise对象，也就是说，我们在后面用链式调用的方式，调用的catch实际上是给前面的then方法返回的promise对象去指定失败回调，并不是直接去给第一个promise对象所指定的。只不过因为这是同一个promise链条，那前面promise上的异常会一直往后传递，所以我们在这里才能捕获到第一个promise中的异常。</li>
<li>而通过then方法第二个参数去指定的失败的回调函数，它只是给第一个promise对象指定的，也就是说它只能捕获到这个promise对象的异常。</li>
</ul>
</li>
<li><p>具体表象上的差异</p>
<ul>
<li>如果我们在then方法中返回了第二个promise，而且这个promise在执行中出现了异常，那我们使用then方法的第二个参数注册的回调，它是捕获不到第二个promise的异常的，因为它只是给第一个promise注册的失败回调。</li>
<li>所以对于链式调用的情况下，建议使用第二种（catch）方式，去分开指定成功回调和失败回调。因为promise链条上任何一个异常都会被一直向后传递直至被捕获。也就是说，这种方式更像是为整个promise链条注册的失败回调，相对说更通用。</li>
</ul>
</li>
</ul>
<h4 id="Promise-静态方法"><a href="#Promise-静态方法" class="headerlink" title="Promise 静态方法"></a>Promise 静态方法</h4><h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><p>Promise.resolve()的作用：快速将一个值转化为promise对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#39;foo&#39;)&#x2F;&#x2F;直接返回一个状态为fulfilled的promise对象,这个&#39;foo&#39;就会作为这个promise对象所返回的值</span><br><span class="line">.then(function(value) &#123;</span><br><span class="line">    console.log(value);&#x2F;&#x2F; foo</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上面等价于下面的</span><br><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">    resolve(&#39;foo&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.resolve方法如果接收到的是另一个promise对象，这个promise对象则会原样返回，也就是我们用Promise.resolve去包裹一个promise，得到的是被包裹的那个promise。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; ajax(&#39;&#x2F;api&#x2F;users.json&#39;);</span><br><span class="line">var promise2 &#x3D; Promise.resolve(promise);</span><br><span class="line">console.log(promise &#x3D;&#x3D;&#x3D; promise2); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>若我们传入的是一个对象，这个对象也有与promise一样的then方法，这样的对象也可以作为一个promise对象被执行，在后面的then方法中也能拿到这里所对应传入的值。</p>
<p>这种带有then方法的对象实现了thenable接口，也就是说它是一个可以被then的对象。支持这种对象的原因，是因为在promise没有普及之前，我们都是使用第三方库去实现promise，如果我们想将第三方的promise对象换成原生的promise，就可以借助这样的机制，因为在第三方promise对象中也有相同的这种then方法，那就可以通过Promise.resolve将其转换成原生的promise对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#123;</span><br><span class="line">  then:function(onFulfilled, onRejected)&#123;</span><br><span class="line">      onFulfilled(&#39;foo&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(value)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><p>Promise.resolve()的作用：快速创建一个失败的promise对象。它的参数，无论我们传入什么参数，都会作为promise失败的理由（失败的原因）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.reject(new Error(&#39;rejected&#39;))</span><br><span class="line">.catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.reject(&#39;anything&#39;)</span><br><span class="line">.catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Promise-并行执行"><a href="#Promise-并行执行" class="headerlink" title="Promise 并行执行"></a>Promise 并行执行</h4><p>前面的操作都是通过promise去串联多个异步任务，也就是一个任务之后，再去开启下一个任务。相对于传统的回调方式Promise提供了更扁平的异步体验。如果需要同时并行执行多个异步任务（比如请求多个接口，且他们之间没有相互依赖），promise也可以提供更完善的体验。</p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()的作用：可以将多个Promise合并为一个Promise统一去管理。</p>
<p>Promise.all():参数是数组，里面是一个个promise对象（每个promise对象可看作是一个异步任务），返回一个全新的promise对象。当内部所有的promise完成之后，我们所返回的这个全新的promise才会完成，此时这个promise对象拿到的结果就是数组，这个数组包含每个异步任务执行后的结果。</p>
<blockquote>
<p>注意：在这个任务过程中，只有这里面的任务都成功结束了，这个新的promise才会成功结束，如果这里有其中一个任务结束了，那这个promise就会以失败结束。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Promise.all()能够很好的处理这种并行的异步请求</span><br><span class="line">var promise &#x3D; Promise.all([</span><br><span class="line">    ajax(&#39;&#x2F;api&#x2F;users.json&#39;),</span><br><span class="line">    ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)</span><br><span class="line">]);</span><br><span class="line">promise.then(function (values)&#123;</span><br><span class="line">    console.log(values); &#x2F;&#x2F; (2) [Array(2), Array(2)]</span><br><span class="line">&#125;).catch(function (error)&#123;</span><br><span class="line">    console.log(error); &#x2F;&#x2F; GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;posts11.json 404 (Not Found)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>综合使用串联和并联这两种方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ajax(&#39;&#x2F;api&#x2F;urls.json&#39;)</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">    const urls &#x3D; Object.values(value);</span><br><span class="line">    const task &#x3D; urls.map(url &#x3D;&gt; ajax(url));&#x2F;&#x2F; 返回的task是promise对象数组</span><br><span class="line">    return Promise.all(task);</span><br><span class="line">&#125;)</span><br><span class="line">.then(values &#x3D;&gt; &#123;</span><br><span class="line">    console.log(values);&#x2F;&#x2F; (2) [Array(2), Array(2)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promis.race()的作用：也可以将多个Promise对象组合成一个全新的Promise对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const request &#x3D; ajax(&#39;&#x2F;api&#x2F;posts.json&#39;)</span><br><span class="line">const timeout &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        reject(new Error(&#39;timeout&#39;))</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 效果：如果500毫秒内请求完成了，就可以正常得到响应结果，如果500毫秒之后，请求就无法将请求返回因为在500毫秒后我们的第二个promise会以失败方式结束，而race方法就是以第一个结束的promise为准</span><br><span class="line">Promise.race([</span><br><span class="line">  request,</span><br><span class="line">  timeout</span><br><span class="line">])</span><br><span class="line">.then(value &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value) &#x2F;&#x2F; Array(2)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error) &#x2F;&#x2F; Error: timeout</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="Promise-all-）与-Promise-race-的区别"><a href="#Promise-all-）与-Promise-race-的区别" class="headerlink" title="Promise.all(）与 Promise.race()的区别"></a>Promise.all(）与 Promise.race()的区别</h5><p>Promose.all()等待所有的任务结束后才会结束（所有的任务成功结束，才会成功结束），Promise.race()只会等待第一个结束的任务，也就是说只要任何一个任务完成了，那我们这个返回的新的Promise也就会完成。</p>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 Proxy使用</title>
    <url>/2021/12/02/proxy/</url>
    <content><![CDATA[<blockquote>
<p>在ES6中，Proxy是为对象设置访问代理器（代理如同门卫），它可以轻松监视到对象的读写过程。</p>
</blockquote>
<a id="more"></a>

<h4 id="Proxy的应用场景示例"><a href="#Proxy的应用场景示例" class="headerlink" title="Proxy的应用场景示例"></a>Proxy的应用场景示例</h4><p>在ES6之前，如果我们想要监视某个对象的属性读写，那我们可以使用ES5提供的Object.defineProperty方法来为我们的对象添加属性，捕获到对象属性的读写过程（Vue3.0之前就是使用这个方法实现数据响应，从而实现数据双向绑定）。</p>
<h4 id="那我们如何使用Proxy？"><a href="#那我们如何使用Proxy？" class="headerlink" title="那我们如何使用Proxy？"></a>那我们如何使用Proxy？</h4><ul>
<li>new Proxy(<code>需要代理的目标对象</code>， <code>代理的处理对象</code>);</li>
<li>首先抛出示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 第一个参数是需要代理的目标对象（person），第二个参数也是一个对象（代理的处理对象）</span><br><span class="line">const personProxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 两个参数：目标对象和属性名</span><br><span class="line">  get(target, property)&#123;</span><br><span class="line">    return property in target ? target[property]: &#39;default&#39;;</span><br><span class="line">    console.log(target, property); &#x2F;&#x2F; &#123; name: &#39;xh&#39;, age: 20 &#125; name</span><br><span class="line">    &#x2F;&#x2F; return 100;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 三个参数：目标对象，属性名，属性值</span><br><span class="line">  set(target, property, value)&#123;</span><br><span class="line">    if(property &#x3D;&#x3D;&#x3D; &#39;age&#39;) &#123; &#x2F;&#x2F; 在这里可以对属性值做一些处理</span><br><span class="line">      if (!Number.isInteger(value))&#123;</span><br><span class="line">        throw new TypeError(&#96;$&#123;value&#125; is not an int&#96;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target[property] &#x3D; value;</span><br><span class="line">    console.log(target, property, value); &#x2F;&#x2F; &#123; name: &#39;xh&#39;, age: 20 &#125; gender true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(personProxy.name); &#x2F;&#x2F; xh</span><br><span class="line">console.log(personProxy.xxx); &#x2F;&#x2F; default</span><br><span class="line">&#x2F;&#x2F; personProxy.age &#x3D; &#39;ss&#39;; &#x2F;&#x2F; 报错</span><br><span class="line">personProxy.gender &#x3D; true</span><br></pre></td></tr></table></figure>
<hr>
<p>都知道在Vue3.0中使用Proxy替代了Object.defineProperty(),那相对于Object.defineProperty()，Proxy有什么优势呢?</p>
<h4 id="Proxy的优势"><a href="#Proxy的优势" class="headerlink" title="Proxy的优势"></a>Proxy的优势</h4><h5 id="Proxy能够监视到更多对象操作"><a href="#Proxy能够监视到更多对象操作" class="headerlink" title="Proxy能够监视到更多对象操作"></a>Proxy能够监视到更多对象操作</h5><p>Proxy更强大一些：defineProperty 只能监视对象属性的读写，而Proxy能够监视到更多对象操作（比如说delete 操作，对对象方法的调用等等）。</p>
<ul>
<li>deleteProperty代理方法：当外部对当前这个代理对象进行delete操作的时,会自动执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line">const personProxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 两个参数：代理目标对象，所删除的属性名</span><br><span class="line">  deleteProperty(target, property)&#123;</span><br><span class="line">    console.log(&#39;delete&#39;, property); &#x2F;&#x2F; delete age</span><br><span class="line">    delete target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">delete personProxy.age;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123; name: &#39;xh&#39; &#125;</span><br></pre></td></tr></table></figure>
<p>当然不仅仅是监视delete操作，还有其他的，Proxy可以检测到的对象操作如下：</p>
<table>
<thead>
<tr>
<th>handler方法</th>
<th>触发方式</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>读取某个属性</td>
</tr>
<tr>
<td>set</td>
<td>写入某个属性</td>
</tr>
<tr>
<td>has</td>
<td>in 操作符</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete 操作符</td>
</tr>
<tr>
<td>getProperty</td>
<td>Object.getPropertypeOf()</td>
</tr>
<tr>
<td>setProperty</td>
<td>Object.setPropertypeOf()</td>
</tr>
<tr>
<td>isExtensible</td>
<td>Object.isExtensible()</td>
</tr>
<tr>
<td>preventExtensions</td>
<td>Object.preventExtensions()</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor</td>
<td>Object.getOwnPropertyDescriptor()</td>
</tr>
<tr>
<td>defineProperty</td>
<td>Object.defineProperty()</td>
</tr>
<tr>
<td>ownkeys</td>
<td>Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()</td>
</tr>
<tr>
<td>apply</td>
<td>调用一个函数</td>
</tr>
<tr>
<td>construct</td>
<td>用 new 调用一个函数</td>
</tr>
</tbody></table>
<p>并且 Proxy 更好的支持数组对象的监视。<br>Object.defineProperty监听对数组的操作，就是重写数组的操作方法，也是Vue.js中所使用的方式（用自定义的方法覆盖掉数组原型上的方法比如说 push 等等），以此来劫持数组调用的过程。</p>
<p>如何使用 Proxy 对象监视数组呢？再举个栗子，你就明白了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list &#x3D; [];</span><br><span class="line">const listProxy &#x3D; new Proxy(list, &#123;</span><br><span class="line">  set(target,property, value) &#123;</span><br><span class="line">    console.log(&#39;set&#39;,property, value);</span><br><span class="line">    target[property] &#x3D; value;</span><br><span class="line">    return true; &#x2F;&#x2F; 表示设置成功</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">listProxy.push(100); &#x2F;&#x2F;set 0 100 (0 是数组下标，100 是数组下标对应的值)</span><br></pre></td></tr></table></figure>
<p>使用Proxy对数组进行监听不需要进行额外的操作，相对于Object.defineProperty就简便很多。</p>
<h5 id="Proxy-是以非侵入的方式监管了对象的读写"><a href="#Proxy-是以非侵入的方式监管了对象的读写" class="headerlink" title="Proxy 是以非侵入的方式监管了对象的读写"></a>Proxy 是以非侵入的方式监管了对象的读写</h5><p>这是什么意思呢：一个已经定义好的对象，我们不需要对对象本身做任何的操作就可以监听到对象的读写。而Object.defineProperty就要求我们必须要经过特定的方式，单独去定义对象当中那些需要被监视的属性，那样对一个已经存在的属性，我们要做很多额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person &#x3D; &#123;&#125;</span><br><span class="line">Object.defineProperty(person, &#39;name&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&#39;name 被访问&#39;);</span><br><span class="line">    return person._name</span><br><span class="line">  &#125;,</span><br><span class="line">  set (value) &#123;</span><br><span class="line">    console.log(&#39;name 被设置&#39;);</span><br><span class="line">    person._name &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person, &#39;age&#39;, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&#39;age 被访问&#39;);</span><br><span class="line">    return person._age</span><br><span class="line">  &#125;,</span><br><span class="line">  set (value) &#123;</span><br><span class="line">    console.log(&#39;age 被设置&#39;);</span><br><span class="line">    person._age &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &#39;jack&#39;;</span><br><span class="line">console.log(person.name); </span><br><span class="line">&#x2F;&#x2F;输出log如下：name 被设置 name 被访问 jack jack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相对于Object.defineProperty方式，Proxy 方式更合理，且代码更加简洁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person2 &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const personProxy &#x3D; new Proxy(person2, &#123;</span><br><span class="line">  get(target, property)&#123;</span><br><span class="line">    return target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, property, value) &#123;</span><br><span class="line">    target[property] &#x3D; value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">personProxy.name &#x3D; &#39;jack&#39;;</span><br><span class="line">console.log(personProxy.name); &#x2F;&#x2F; jack</span><br></pre></td></tr></table></figure>

<h5 id="Proxy监听性能有所提升"><a href="#Proxy监听性能有所提升" class="headerlink" title="Proxy监听性能有所提升"></a>Proxy监听性能有所提升</h5><p>Proxy监听相对于Object.defineProperty性能更好。因为Proxy在get里进行递归（不get就不递归），什么时候用（也就是说什么时候get到）什么时候才监听，而Object.defineProperty是一次性全部递归完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">const proxyData &#x3D; new Proxy(data, &#123;</span><br><span class="line">    get(target, key, receiver) &#123;</span><br><span class="line">        &#x2F;&#x2F; 只处理本身（非原型的）属性</span><br><span class="line">        const ownKeys &#x3D; Reflect.ownKeys(target)</span><br><span class="line">        if (ownKeys.includes(key)) &#123;</span><br><span class="line">            console.log(&#39;get&#39;, key) &#x2F;&#x2F; 监听</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const result &#x3D; Reflect.get(target, key, receiver)</span><br><span class="line">        return result &#x2F;&#x2F; 返回结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Proxy总结"><a href="#Proxy总结" class="headerlink" title="Proxy总结"></a>Proxy总结</h4><blockquote>
<p>Proxy 能够监视到更多对象操作,比如说可监听 新增/删除 属性等等<br>Proxy 是以非侵入的方式监管了对象的读写<br>Proxy 性能更好</p>
</blockquote>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 可迭代接口 Iterable</title>
    <url>/2021/12/02/Iterable/</url>
    <content><![CDATA[<blockquote>
<p>为给各种各样的数据结构提供统一的遍历方式，ES6提供了Iterable接口。</p>
</blockquote>
<a id="more"></a>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>在学习ES6的新特性学到<code>for...of</code>的时候，有个问题让我非常困惑，有的资料说<code>for...of</code>循环这种循环方式以后会作为遍历所有数据结构的统一方式,为什么使用<code>for...of</code>遍历普通对象会报错？</p>
</blockquote>
<p>原来是ECMAScript能够表示有结构的数据的数据类型越来越多，从最早的数组，对象，现在又增加了Set、Map,而这些又可以结合使用。为了给各种各样的数据结构提供统一遍历方式，ES2015就提供了Iterable接口（可迭代的），例如任意数据类型都有toString方法，那是因为都实现了统一的规格标准（这种统一的规格标准在编程的专业叫法叫接口）,因为普通对象内部没有实现Iterable接口，所以它不能被for…of遍历。</p>
<blockquote>
<p>那又为什么说for…of循环可以作为遍历所有数据结构的统一方式？</p>
</blockquote>
<p>因为它内部就是去调用被遍历对象的Iterable方法，去得到一个迭代器，从而去遍历内部所有的数据。这也是Iterable接口所约定的内容。换句话说，只要我们的对象也实现了Iterable接口，那就可以实现使用<code>for...of</code>循环去遍历我们的的对象。</p>
<h4 id="Iterable接口实现的内容"><a href="#Iterable接口实现的内容" class="headerlink" title="Iterable接口实现的内容"></a>Iterable接口实现的内容</h4><p>首先，Iterable接口约定的就是我们对象当中必须要挂载一个叫 Iterable的方法。这里举一些画在Iterable接口的几种数据，比如说：Array、Set、Map等等。</p>
<p>Array:</p>
<img src="/2021/12/02/Iterable/iteratorArr.jpg" class title="This is an image">

<p>Set:</p>
<img src="/2021/12/02/Iterable/iteratorSet.png" class title="This is an image">

<p>Map:</p>
<img src="/2021/12/02/Iterable/iteratorMap.png" class title="This is an image">

<p>这些数据内部都实现了Iterable接口，所以他们都能被for…of遍历。</p>
<p>那这个Iterable 方法是干什么的呢?</p>
<p>在arr<a href>Symbol.iterator</a>调用后会返回一个数组迭代器对象（Array Iterator {}），这个迭代器中维护了一个数据指针，我们每调用一次next，这个指针都会往后移一位，而done属性的作用就是表示我们内部的属性是否全部被遍历完了。</p>
<img src="/2021/12/02/Iterable/iteratorPic.png" class title="This is an image">


<blockquote>
<p>总结一下：所有能直接被 for…of循环遍历的数据类型，它都必须要实现Iterable的接口，就是它在内部都必须要挂载Iterable方法，这个方法要返回一个带有next方法的对象，我们不断调用这个next方法就实现了对数据的遍历。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const set &#x3D; new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]);</span><br><span class="line"></span><br><span class="line">const iterable &#x3D; set[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">console.log(iterable.next()); &#x2F;&#x2F; &#123; value: &#39;foo&#39;, done: false &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: &#39;bar&#39;, done: false &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: &#39;baz&#39;, done: false &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line">console.log(iterable.next());&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现可迭代接口Iterable"><a href="#实现可迭代接口Iterable" class="headerlink" title="实现可迭代接口Iterable"></a>实现可迭代接口Iterable</h4><p>如何在ECMAScript中去实现Iterable接口？</p>
<p>它实际上就是在这个对象中挂载一个Iterable方法，然后在这个方法中去返回一个迭代器对象。挂载一个Iterable方法，主要有三个方面需要满足：</p>
<blockquote>
<ol>
<li>在最外面的对象实现可迭代接口，叫 Iterable，这个接口约定了内部必须要有一个用于返回迭代器的Iterator方法；</li>
<li>在中间的Iterator返回的对象，它实现了迭代器接口，叫Iterator，这个接口约定的是内部必须 要有一个用于迭代的next方法；</li>
<li>在next返回的对象，这个对象实现的是迭代结果接口，叫IterationResult。这个接口约定的就是，我们在这个对象的内部必须要有Value属性用来表示当前被迭代到的数据,它的值可以是任意类型，除此之外还必须有done和布尔值，这个属性用来表示迭代有没有结束。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  [Symbol.iterator]: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      next:function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: &#39;xh&#39;,</span><br><span class="line">          done: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们实现一个能够被<code>for...of</code>遍历的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  store: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;],</span><br><span class="line">  [Symbol.iterator]: function() &#123;</span><br><span class="line">    let index &#x3D; 0;</span><br><span class="line">    const self &#x3D; this; &#x2F;&#x2F; next函数中的this并不是obj对象</span><br><span class="line">    return &#123;</span><br><span class="line">      next:function() &#123;</span><br><span class="line">        const result &#x3D;  &#123;</span><br><span class="line">          value: self.store[index],</span><br><span class="line">          done: index &gt;&#x3D; self.store.length</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        return result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const item of obj) &#123;</span><br><span class="line">  console.log(item); &#x2F;&#x2F; foo bar baz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Iterable</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 之 Reflect</title>
    <url>/2021/12/02/reflect/</url>
    <content><![CDATA[<blockquote>
<p>Reflect是ES6中提供的一种全新的内置对象（统一的对象操作API）。</p>
</blockquote>
<a id="more"></a>

<h4 id="Reflect的作用"><a href="#Reflect的作用" class="headerlink" title="Reflect的作用"></a>Reflect的作用</h4><p>刚开始接触Reflect的时候，我在想为什么需要这个东西？</p>
<p>查了一些资料才发现，Reflect最大的意义就是：<strong>统一提供一套用于操作对象的API</strong>。因为在这之前呢，我们去操作对象时有可能用Object对象上的一些方法，也可能是用delete 、in这样的操作符。那这样对于新手来说太乱了，并没有什么规律，Reflect对象就很好的解决了这样的问题，它统一了对象的操作。</p>
<p>例如下面的例子，我们可以用<code>Reflect.has()</code>代替<code>in</code>操作符，使用<code>Reflect.deleteProperty</code>代替<code>delete</code>操作符。这样看起来就很统一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  name: &#39;xh&#39;,</span><br><span class="line">  age:18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#39;name&#39; in obj); &#x2F;&#x2F; true 使用的是操作符</span><br><span class="line">console.log(delete obj[&#39;age&#39;]);&#x2F;&#x2F; true 使用的是操作符</span><br><span class="line">console.log(Object.keys(obj)); &#x2F;&#x2F; [&#39;name&#39;]  使用的是对象方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用新的Reflect方式，进行同样的操作</span><br><span class="line"></span><br><span class="line">console.log(Reflect.has(obj, &#39;name&#39;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Reflect.deleteProperty(obj, &#39;age&#39;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(Reflect.ownKeys(obj)); &#x2F;&#x2F; [&#39;name&#39;]</span><br></pre></td></tr></table></figure>
<p>注意：以前的那种操作方式还是可以使用的，ECMAScript官方希望经过一段时间，以后的标准当中就会将之前的那些方式废弃掉，推荐使用Reflect。</p>
<h4 id="Proxy与Reflect配合使用"><a href="#Proxy与Reflect配合使用" class="headerlink" title="Proxy与Reflect配合使用"></a>Proxy与Reflect配合使用</h4><p>Reflect属于一个静态类，它不能通过new Reflect的方式去构建一个实例对象，只能够去调用这个静态类中的静态方法（如 Math 对象一样）。而且Reflect内部封装了一系列对对象的底层操作。提供了14个静态方法，其中有一个废弃掉了，剩下13个。这个13个对象的方法的方法名与<a href="https://laceyx.github.io/2021/01/22/proxy/#more">Proxy中对象中处理对象的方法成员是完全一致的</a>。Reflect成员方法就是Proxy处理对象的默认实现。</p>
<p>在Proxy处理对象中，如果我们没有添加具体的处理方法（比如get/set），那么它的内部这些get/set到底是怎样执行的呢？看个小例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;123&#39;,</span><br><span class="line">  bar: &#39;456&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const proxy &#x3D; new Proxy(obj, &#123;</span><br><span class="line">  &#x2F;&#x2F; 我们在定义get&#x2F;set 这样的逻辑时，更标准的做法是：先去实现自己所需要的js逻辑，</span><br><span class="line">  &#x2F;&#x2F; 最后返回通过Reflect中对应方法调用的结果。</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    console.log(&#39;watch login~&#39;); &#x2F;&#x2F;模拟我们调用的js逻辑</span><br><span class="line">    return Reflect.get(target, property)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(proxy.foo) </span><br></pre></td></tr></table></figure>
<p>其实Proxy处理对象内部，默认实现的逻辑就是调用了Reflect对象当中所对应的方法。也就是说我们没有定义get方法就等同于是我们定义了一个get方法，然后将参数原封不动传给Reflect的get方法，这个结果是一样的。</p>
<p>我们在定义get/set这样的逻辑时，更标准的做法是：先去实现自己所需要的js逻辑，最后返回通过Reflect中对应方法调用的结果。</p>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/08/AsyncCode/AsyncCode2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ES6 之 Symbol</title>
    <url>/2021/12/02/symbol/</url>
    <content><![CDATA[<blockquote>
<p>Symbol是一种全新的基本数据类型，在未来可能还会添加一个BigInt的原始数据类型，用于存放更长的数字(这个现在处于stage-4阶段，标准化之后，那就有8种原始数据类型)。</p>
</blockquote>
<a id="more"></a>

<h4 id="为什么需要Symbol？"><a href="#为什么需要Symbol？" class="headerlink" title="为什么需要Symbol？"></a>为什么需要Symbol？</h4><p>在ES6之前对象的属性名都是字符串，而字符串的属性名是有可能重复的，那重复就会产生冲突。</p>
<h4 id="实际场景出现的问题"><a href="#实际场景出现的问题" class="headerlink" title="实际场景出现的问题"></a>实际场景出现的问题</h4><p>很多情况下我们大量使用第三方模块，很多时候我们需要扩展第三方模块中的对象，此时我们不知道这个对象中是否存在某个指定的键，如果这时候贸贸然直接扩展，就有可能会产生冲突。</p>
<h4 id="以前的解决方案"><a href="#以前的解决方案" class="headerlink" title="以前的解决方案"></a>以前的解决方案</h4><p>以前是采用约定的方式，例如，a文件下的键就命名为a_foo,b文件下就命名为b_foo,但是这并没有解决问题，只是规避问题。假如在多人合作开发时有人遵守约定，那就很容易出问题。</p>
<p>举个约定的栗子(便于展示，这里用 ==== 代表一个单独的文件)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; share.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">const cache &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;a.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">cache[&#39;a_foo&#39;] &#x3D; Math.random();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">cache[&#39;b_foo&#39;] &#x3D; &#39;123&#39;;</span><br></pre></td></tr></table></figure>
<p>而ES6为了解决上述问题，提供了一个全新的原始数据类型Symbol</p>
<h4 id="Symbol的作用"><a href="#Symbol的作用" class="headerlink" title="Symbol的作用"></a>Symbol的作用</h4><p>Symbol的作用是表示一个独一无二的值。在实际应用中，它最主要的作用就是为对象添加独一无二的属性名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s &#x3D; Symbol();</span><br><span class="line">console.log(s); &#x2F;&#x2F; Symbol()</span><br><span class="line">console.log(typeof s) &#x2F;&#x2F; symbol</span><br><span class="line"></span><br><span class="line">console.log(Symbol() &#x3D;&#x3D;&#x3D; Symbol());&#x2F;&#x2F; false，值是唯一的，我们没有办法去创建一个完全一样的Symbol成员</span><br></pre></td></tr></table></figure>
<h4 id="Symbol-的使用"><a href="#Symbol-的使用" class="headerlink" title="Symbol 的使用"></a>Symbol 的使用</h4><h5 id="Symbol允许传入字符串参数"><a href="#Symbol允许传入字符串参数" class="headerlink" title="Symbol允许传入字符串参数"></a>Symbol允许传入字符串参数</h5><p>考虑到开发中的调试，Symbol函数允许我们传入字符串作为调试文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Symbol(&#39;foo&#39;));&#x2F;&#x2F; Symbol(foo)</span><br><span class="line">console.log(Symbol(&#39;bar&#39;));&#x2F;&#x2F; Symbol(bar)</span><br><span class="line">console.log(Symbol(&#39;baz&#39;));&#x2F;&#x2F; Symbol(baz)</span><br></pre></td></tr></table></figure>
<h5 id="使用Symbol作为对象属性名"><a href="#使用Symbol作为对象属性名" class="headerlink" title="使用Symbol作为对象属性名"></a>使用Symbol作为对象属性名</h5><p>在ES6及之后，对象允许使用Symbol类型的值作为属性名。现在对象的属性名可以是两种类型：string和Symbol。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;</span><br><span class="line">obj[Symbol()] &#x3D; &#39;123&#39;</span><br><span class="line">obj[Symbol()] &#x3D; &#39;456&#39;;</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; [Symbol()]: &#39;123&#39;, [Symbol()]: &#39;456&#39; &#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    [Symbol()]: 123</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);&#x2F;&#x2F; &#123; [Symbol()]: 123 &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Symbol去创建私有属性"><a href="#使用Symbol去创建私有属性" class="headerlink" title="使用Symbol去创建私有属性"></a>使用Symbol去创建私有属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; 使用Symbol去创建私有的属性名</span><br><span class="line">const name &#x3D; Symbol();</span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">    [name]: &#39;xh&#39;,</span><br><span class="line">    say() &#123;</span><br><span class="line">        console.log(this[name]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; b.js &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F; person[Symbol()];&#x2F;&#x2F; 访问不到a.js文件中的person的name属性</span><br><span class="line">person.say();&#x2F;&#x2F; xh</span><br></pre></td></tr></table></figure>
<h4 id="Symbol补充"><a href="#Symbol补充" class="headerlink" title="Symbol补充"></a>Symbol补充</h4><h5 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h5><p>每次通过Symbol函数创建的值一定是唯一值，不管我们传入的描述文本是不是相同的，那每次调用Symbol函数它得到的值都是全新的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(</span><br><span class="line">  Symbol() &#x3D;&#x3D;&#x3D; Symbol(), &#x2F;&#x2F; false</span><br><span class="line">  Symbol(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; Symbol(&#39;foo&#39;) &#x2F;&#x2F; false</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="如何在全局复用相同的Symbol值？"><a href="#如何在全局复用相同的Symbol值？" class="headerlink" title="如何在全局复用相同的Symbol值？"></a>如何在全局复用相同的Symbol值？</h5><ul>
<li>使用全局变量的方式去实现</li>
<li>使用Symbol类型提供的静态方法（for）去实现<ul>
<li>使用for方法，这个方法可以接受一个字符串作为参数，相同的字符串就一定会返回相同的Symbol类型的值。这个方法内部维护了一个全局的注册表，为我们的字符串和symbol值提供了一一对应的关系。</li>
<li><blockquote>
<p>注意：这个方法内部维护的是字符串和symbol值一一对应的关系，如果我们传入的不是字符串，那这个方法会将其自动转换为字符串。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const s1 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">const s2 &#x3D; Symbol.for(&#39;foo&#39;);</span><br><span class="line">console.log(s1 &#x3D;&#x3D;&#x3D; s2);&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Symbol.for(&#39;true&#39;) &#x3D;&#x3D;&#x3D; Symbol.for(true)</span><br><span class="line">); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h5 id="Symbol内置常量"><a href="#Symbol内置常量" class="headerlink" title="Symbol内置常量"></a>Symbol内置常量</h5><p>Symbol类型中提供了很多内置Symbol常量，用来去作为内部方法的标识，这些标识符可以让自定义对象去实现一些JS中内置的接口。例如：iterator、hasInstance等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这种symbol（symbol常量）为我们后面为对象实现迭代器时会经常用到</span><br><span class="line">console.log(Symbol.iterator);</span><br><span class="line">console.log(Symbol.hasInstance);</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 自定义对象的toString标签：可以添加一个特定的成员去标识（使用字符串去添加标识符，可能会跟内部成员产生冲突，ECMAScript要求我们使用Symbol来实现这个标识）</span><br><span class="line">  [Symbol.toStringTag]: &#39;Xobject&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;原本的： [object Object] &#x3D;&#x3D;&gt;叫对象的toString标签</span><br><span class="line">console.log(obj.toString()) &#x2F;&#x2F;修改后的： [object Xobject]</span><br></pre></td></tr></table></figure>
<h5 id="使用symbol值去作为对象的属性名"><a href="#使用symbol值去作为对象的属性名" class="headerlink" title="使用symbol值去作为对象的属性名"></a>使用symbol值去作为对象的属性名</h5><p>使用symbol值去作为对象的属性名，通过for…of..循环、Object.keys()、JSON.toStringify()序列化，都是获取不到的。这种特性表示Symbol类型特别适合作为对象的私有属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  [Symbol()]: &#39;symbol value&#39;,</span><br><span class="line">  for: &#39;normal value&#39;</span><br><span class="line">&#125;</span><br><span class="line">for (var key in obj) &#123;</span><br><span class="line">  console.log(key); &#x2F;&#x2F; foo</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(obj));&#x2F;&#x2F; [&#39;foo&#39;]</span><br><span class="line">console.log(JSON.stringify(obj)) &#x2F;&#x2F; &#123;&quot;for&quot;:&quot;normal value&quot;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何获取symbol类型的属性名"><a href="#如何获取symbol类型的属性名" class="headerlink" title="如何获取symbol类型的属性名"></a>如何获取symbol类型的属性名</h5><p>使用Object.getOwnPropertySymbols(obj)方法，作用与Object.keys方法类似。不同的是Object.keys方法只能获取到对象中所有的字符串属性名，而Object.getOwnPropertySymbols(obj)方法，它获取到的全是Symbol属性名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Object.getOwnPropertySymbols(obj)); &#x2F;&#x2F; [ Symbol() ]</span><br></pre></td></tr></table></figure>
<p>感谢您的阅读～</p>
]]></content>
      <categories>
        <category>ES6+系列</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程初识</title>
    <url>/2021/12/04/AsyncCode/AsyncCode1/</url>
    <content><![CDATA[<blockquote>
<p>单线程 JavaScript 异步方案。本篇讲述异步编程的某些概念，以及需要异步编程方案的原因</p>
</blockquote>
<a id="more"></a>

<h3 id="异步编程：单线程-JavaScript-异步方案"><a href="#异步编程：单线程-JavaScript-异步方案" class="headerlink" title="异步编程：单线程 JavaScript 异步方案"></a>异步编程：单线程 JavaScript 异步方案</h3><p>目前主流的JavaScript环境都是以单线程模式去执行的JavaScript代码</p>
<h4 id="采用单线程模式工作的原因"><a href="#采用单线程模式工作的原因" class="headerlink" title="采用单线程模式工作的原因"></a>采用单线程模式工作的原因</h4><p>与它最早的设计初衷有关，最早JavaScript这门语言就是运行在浏览器端的脚本语言，它的目的就是实现页面中的动态交互，交互的核心就是进行DOM操作，这也就决定了它必须使用单线程模型，否则就会出现很复杂的线程同步问题。</p>
<p>试想一下，假定我们在JavaScript中同时有多个线程同时工作，其中某一个线程修改了某个DOM元素，而另外一个线程同时又删除了该DOM元素，那此时浏览器就无法明确该以哪个线程的结果为准，为了避免这些线程同步问题。JavaScript一开始就设计了单线程模式工作。</p>
<h4 id="单线程：JS执行环境中负责执行代码的线程只有一个。"><a href="#单线程：JS执行环境中负责执行代码的线程只有一个。" class="headerlink" title="单线程：JS执行环境中负责执行代码的线程只有一个。"></a>单线程：JS执行环境中负责执行代码的线程只有一个。</h4><ul>
<li>优点：更安全，更简单</li>
<li>缺点：如果我们遇到某个特别耗时的任务，那后面的任务都必须去排队等待这个任务的结束。导致整个程序的执行会被拖延，出现假死的情况。</li>
<li>为了解决耗时任务阻塞执行的这种问题，JavaScript将任务的执行模式分成了两种<ul>
<li>同步模式（Synchronous）</li>
<li>异步模式（Asynchronous）</li>
</ul>
</li>
</ul>
<h3 id="同步模式（Synchronous）"><a href="#同步模式（Synchronous）" class="headerlink" title="同步模式（Synchronous）"></a>同步模式（Synchronous）</h3><p>概念：同步模式指的就是我们代码当中的任务依次执行，那我们后一个任务必须等到前一个任务结束才能开始执行。程序的执行顺序跟我们代码的编写顺序是完全一致的。<br>在单线程情况下，我们大多数任务会以同步模式去执行。</p>
<p>示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;global begin&#39;)</span><br><span class="line">function bar () &#123;</span><br><span class="line">  console.log(&#39;bar task&#39;);</span><br><span class="line">&#125;</span><br><span class="line">function foo () &#123;</span><br><span class="line">  console.log(&#39;foo task&#39;);</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(&#39;global end&#39;)</span><br></pre></td></tr></table></figure>
<p>在console 中的执行显示  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global begin</span><br><span class="line">foo task</span><br><span class="line">bar task</span><br><span class="line">global end</span><br></pre></td></tr></table></figure>
<h5 id="在调用栈中的执行过程"><a href="#在调用栈中的执行过程" class="headerlink" title="在调用栈中的执行过程"></a>在调用栈中的执行过程</h5><ul>
<li>默认压入一个匿名的调用（anonymous）：可以理解为把全部的代码放在一个匿名的函数中去执行，然后逐行执行我们的代码</li>
<li>console.log(‘global begin’)执行，log打印后，然后弹出</li>
<li>foo()-&gt;console.log(‘foo task’);执行，log打印后，然后弹出 -&gt; bar() -&gt;console.log(‘bar task’);执行，log打印后，</li>
<li>然后弹出 -&gt; bar函数执行结束，然后弹出 -&gt; foo函数执行结束，然后弹出</li>
<li>console.log(‘global end’)，执行，log打印，弹出<br>整体代码全部结束，我们的调用栈就被清空掉</li>
</ul>
<blockquote>
<p>这里的调用栈只是一个专业的说法，通俗说，JS在执行引擎中维护了一个正在工作的工作表，记录当前正在做的一些事情，当这个工作表中所有的任务被清空后，这一轮的工作就结束了。</p>
</blockquote>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>如果其中的某一个任务或者某一行代码，执行时间过长，那后面的任务就会被延迟，我们把这种延迟叫做阻塞。</p>
<p>这种阻塞于用户而言就是页面就会卡顿，就必须要有异步模式来去解决我们程序当中那些无法避免的耗时操作（例如我们在浏览器中的Ajax操作，或者node端的大文件读写）。</p>
<h3 id="异步模式（Asynchronous）"><a href="#异步模式（Asynchronous）" class="headerlink" title="异步模式（Asynchronous）"></a>异步模式（Asynchronous）</h3><blockquote>
<p>特点：不会去等待这个任务的结束才开始下一个任务。对于耗时任务，它都是开启过后就立即往后执行下一个任务，耗时任务的后续逻辑一般会通过回调函数的方式定义。耗时任务完成后会自动执行我们传入的回调函数。</p>
</blockquote>
<p>异步模式对于JavaScript非常重要，因为如果没有异步模式，单线程的JavaScript 语言就无法同时处理大量耗时任务。  </p>
<p>异步模式的代码执行顺序是比较混乱的，示例代码的执行顺序如下</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;global begin&#39;);</span><br><span class="line">setTimeout(function timer1 ()&#123;</span><br><span class="line">  console.log(&#39;timer1 invoke&#39;);</span><br><span class="line">&#125;,1800)</span><br><span class="line">setTimeout(function timer2()&#123;</span><br><span class="line">  console.log(&#39;timer2 invoke&#39;);</span><br><span class="line">  setTimeout(function timerInner()&#123;</span><br><span class="line">      console.log(&#39;inner invoke&#39;)</span><br><span class="line">  &#125;,1000)    </span><br><span class="line">&#125;,1000)</span><br><span class="line">console.log(&#39;global end&#39;);  </span><br></pre></td></tr></table></figure>
<h5 id="Call-stack"><a href="#Call-stack" class="headerlink" title="Call stack"></a>Call stack</h5><ul>
<li><p>首先压入一个匿名的全局调用（anonymous）<br>压栈console.log(‘global begin’)，打印后弹出栈<br>setTimeout(timer1)压栈（异步调用，需要关心内部API环境是怎么工作的），setTimeout(timer1)弹出，后面代码继续执行</p>
</li>
<li><p>setTimeout(timer2)压栈（异步调用，需要关心内部API环境是怎么工作的），setTimeout(timer2)弹出，后面代码继续执行</p>
</li>
<li><p>压栈console.log(‘global end’)，打印后弹出栈。匿名调用已经执行完成，调用栈会被清空</p>
</li>
<li><p>( 对于调用栈来说是开启新一轮的执行，执行过程于上面分析的是一致的)</p>
</li>
<li><p>将()压入栈，继续执行timer2(),打印，然后弹出栈</p>
</li>
<li><p>遇到异步调用，setTimeout(inner)压栈，（异步调用，需要关心内部API环境是怎么工作的），setTimeout(inner)弹出，后面代码继续执行</p>
</li>
</ul>
<p>打印结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console</span><br><span class="line">global begin</span><br><span class="line">global end</span><br><span class="line"></span><br><span class="line">timer2 invoke</span><br><span class="line">timer1 invoke</span><br><span class="line">inner invoke</span><br></pre></td></tr></table></figure>
<p>Web APIs（内部API环境，这里以web平台举例）</p>
<ul>
<li>为timer1 （1.8秒）函数开启了一个计数器（开始倒数），这是单独工作的，并不受当前JS线程影响</li>
<li>为timer2（1秒）函数又开启一个计数器（开始倒数），这是单独工作的，并不受当前JS线程影响</li>
<li>timer2倒计时先结束，timer2函数就会放在我们消息队列的第一位，</li>
<li>tomer1倒计时结束，timer1就会放在消息队列的第二位</li>
<li>为timerInner(1秒)函数开启了一个计数器（开始倒计时），这是单独工作的，并不受当前JS线程影响</li>
</ul>
<h4 id="事件循环和消息队列（Queue）"><a href="#事件循环和消息队列（Queue）" class="headerlink" title="事件循环和消息队列（Queue）"></a>事件循环和消息队列（Queue）</h4><p>event loop开始发挥作用（它只做一件事情：监听调用栈和消息队列，一旦调用栈中所有的任务都结束了，事件循环就会从消息队列中取出第一个回调函数，然后压如到调用栈），只不过此时我们的消息队列是空的，所以执行相当于暂停下来了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列中： timer2()    timer1() </span><br></pre></td></tr></table></figure>
<p>当消息队列中发生了变化，事件循环就会监听到，把消息队列中的第一个（timer2）取出来押入我们的调用栈，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列中：timer1()      timerInner()</span><br></pre></td></tr></table></figure>
<p>然后就是不断的重复，直到我们的调用栈和消息队列中都没有需要继续执行的任务了，整体的代码就执行结束了</p>
<h5 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h5><p>调用栈是一个正在执行的工作表，那消息队列就是一个待办的工作表，而js执行引擎就是先去做完调用栈中所有的任务，然后再通过事件循环，从消息队列中在取一个任务出来，继续执行，以此类推。</p>
<p>我们随时可以往消息队列中放入一些任务，这些任务会排队等候事件循环。以上就是异步调用在JavaScript中的实现过程以及基本原理，整个过程就是通过内部消息队列和事件循环去实现的。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>这之间并没有事件先后关系，他们各自都有各自的time line，例如我们的计时器，它开始之后就会直接开始倒计时，根本不过管调用栈或队列中是什么情况。这里是便于理解。</p>
<p>总结如下图</p>


<h5 id="解释如下："><a href="#解释如下：" class="headerlink" title="解释如下："></a>解释如下：</h5><p>比如JavaScript线程在某个时刻发起了一个异步调用，然后它紧接着继续执行本轮的其他任务；</p>
<p>此时异步线程会单独去执行这个异步任务，然后在执行完这个异步任务之后，会将这个异步任务的回调放入消息队列中；</p>
<p>js主线程它完成所有的任务之后，会依次执行消息队列中的任务。</p>
<h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><p>JavaScript 确实是单线程的，而我们的浏览器不是单线程的。我们通过JavaScript调用的某些内部的API并不是单线程的，例如我们这里的倒时器，那它内部会有一个单独的线程去负责倒数，等时间到了之后，将回调放入消息队列（也就是说这样一个事情它是由一个单独的线程去做的）。</p>
<p>我们所说的单线程指的是执行我们代码的线程是一个线程。也就是说这些内部的API它们会用单独的线程去执行这些等待的操作。</p>
<p>我们这里的同步异步，并不是指我们写代码的方式，而是指运行环境提供的API是以同步或异步模式的方式去工作。</p>
<p>对于同步模式的API的特点就是这个任务执行完，它的代码才会继续往下走（例如console.log()）;对于异步模式的API，就是下达这个任务开启过后的指令，就会继续往下执行，代码是不会在这一行等待任务的结束的（例如setTimeout()）。</p>
]]></content>
      <categories>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
</search>
